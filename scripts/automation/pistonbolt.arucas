import * from Minecraft;
import Java from util.Internal;
import NestedCommand from util.CommandLib;
import * from util.PosUtils;
import PistonUtils from util.PistonUtils;

client = MinecraftClient.getClient();
clientJava = Java.valueOf(client);

jWorld = clientJava.world;
player = client.getPlayer();
world = client.getWorld();
playerReach = 4.5;
accurateBlockPlacement = false;
carefulBreakSneak = false;
messageHolder = new MessageHolder();

messageHolder.debugFlag = true;

taskInterval = 15; //10ms interval
serverPing = 150;
trustClient = true;
tickCount = 2;
immediateInterval = 0;
//Hardcode sequences
Mapping_Diagonal =   {0 : 'rail', 1 : 'redstone_torch', 2 : 'repeater', 3 : 'sticky_piston', 4 : 'shroomlight', 5 : 'white_carpet', 6 : 'redstone', 7 : 'sea_lantern'};
Mapping_Straight =   {0 : 'rail', 1 : 'redstone_torch', 2 : 'repeater', 3 : 'piston', 4 : 'shroomlight', 5 : 'white_carpet', 6 : 'redstone', 7 : 'sea_lantern'};
Mapping_Straight_v2 = {0 : 'rail', 1 : 'redstone_torch', 2 : 'repeater', 3 : 'piston', 4 : 'shroomlight', 5 : 'white_carpet', 6 : 'redstone', 7 : 'sea_lantern', 8 : 'powered_rail'};
NORTH = new Direction('north');
SOUTH = new Direction('south');
WEST = new Direction('west');
EAST = new Direction('east');
UP = new Direction('up');
DOWN = new Direction('down');
pause = false;
sleepInterval = 0;
hideMessage = false;

// Functions
fun assertInHotbar(items){
    //put all items in hotbar.
    //This should only be called when total count is less then 10.
    availableSet = new DefaultedMap([0,1,2,3,4,5,6,7,8]);
    itemSet = new DefaultedMap(items);
    foreach ( itemString : items){
        hotbarKey = isInHotbar(itemString);
        if ( hotbarKey != null){
        availableSet.remove(hotbarKey);
        itemSet.remove(itemString);
        }
    }
    //now leftorvers
    foreach( itemString : itemSet.getKeys()){
        retval = swapHotbarSlotWithItem(availableSet.poll(), itemString);
        if (retval == null){
            throwRuntimeError("Cannot swap item " + itemString + ' with slot number '+ availableSet.poll());
        }
        availableSet.remove(retval);
    }
}
fun swapHotbarSlotWithItem(slotNum, itemString){
    //swaps hotbar slot number with desired item, returns result.
    //first check hotbar
	foreach(i : [0,1,2,3,4,5,6,7,8]){
		if(player.getItemForPlayerSlot(i).getId().contains(itemString)){
			return i;
		}
	}
	//then check all items
    if (itemString == 'pickaxe'){
	    slot = player.getSlotFor(ItemStack.of(Material.of("diamond_pickaxe")));
	    if (slot == null) {
	    	slot = player.getSlotFor(ItemStack.of(Material.of("netherite_pickaxe")));
	    }
    }
    else {
        slot = player.getSlotFor(ItemStack.of(Material.of(itemString)));
    }
    if (slot == null){
    //no items found.
        return false;
    }
    player.swapSlots(slotNum + 36, slot);
    return slotNum;
}
fun isInHotbar(itemString){
	foreach(i : [0,1,2,3,4,5,6,7,8]){
		if(player.getItemForPlayerSlot(i).getId().contains(itemString)){
			return i;
		}
	}
	return null;
}
fun checkCanPlaceAt(position, block){
    jBlock = Java.valueOf(block); //blockState
    jPosition = position.asJavaPos();
    return jBlock.getBlock().canPlaceAt(jBlock, jWorld, jPosition).toArucas();
}
fun swapToItem(itemString){
    if (player.getItemForSlot(player.getCurrentSlot() + 36).getId() == itemString){
        return true;
    }
	if (itemString == "air") {
		swapToPickaxe();
		return false;}
	foreach(i : [0,1,2,3,4,5,6,7,8]){
		if(player.getItemForPlayerSlot(i).getId() == itemString){
			player.setSelectedSlot(i);
			return true;
		}
	}
	slot = player.getSlotFor(ItemStack.of(Material.of(itemString)));
	retVal = false;
	if (slot == null) {
	    if (player.getGamemode() == 'creative'){
	        messageHolder.sendDebugMessage('pick from creative');
	        preslot = player.getSwappableHotbarSlot();
	        clientJava.interactionManager.clickCreativeStack(Java.valueOf(ItemStack.of(Material.of(itemString))), Java.intOf(36 + player.getCurrentSlot()));
	        player.setSelectedSlot(preslot);
	        return true;
	    }
	}
	if (slot != null) {
		if (0 <= slot-36 && slot-36  <= 8) {
		    player.setSelectedSlot(slot-36);
		    return true;
		}
		else {
			preslot = player.getSwappableHotbarSlot();
			player.swapPlayerSlotWithHotbar(slot);
			player.setSelectedSlot(preslot);
			return true;
		}
	}
	return null;
}
fun checkItem(itemString){
    if (player.getGamemode() == 'creative'){
        return true;
    }
    if (player.getItemForSlot(player.getCurrentSlot() + 36).getId() == itemString){
        return true;
    }
	foreach(i : [0,1,2,3,4,5,6,7,8]){
		if(player.getItemForPlayerSlot(i).getId() == itemString){
			return true;
		}
	}
	slot = player.getSlotFor(ItemStack.of(Material.of(itemString)));
	retVal = false;
	if (slot == null) {return false;}
	if (slot != null) {
		if (0 <= slot-36 && slot-36  <= 8) {
		    return true;
		}
		else {
			preslot = player.getSwappableHotbarSlot();
			return true;
		}
	}
	messageHolder.sendMessage("Can't find "+ itemString+" in inventory");
	return null;
}
// Swaps to pickaxe.
fun swapToPickaxe(){
    if (player.getItemForSlot(player.getCurrentSlot() + 36).getId().contains("pickaxe")){
        return true;
    }
	slot = player.getSlotFor(ItemStack.of(Material.of("diamond_pickaxe")));
	if (slot == null) {
		slot = player.getSlotFor(ItemStack.of(Material.of("netherite_pickaxe")));
	}
	if (slot != null) {
		if (0 <= slot-36 && slot-36  <= 8) {
		    player.setSelectedSlot(slot-36);
		    return true;
		}
		else {
			preslot = player.getSwappableHotbarSlot();
			player.swapPlayerSlotWithHotbar(slot);
			player.setSelectedSlot(preslot);
			return true;
		}
	}
	if (slot == null) {
	    if (player.getGamemode() == 'creative'){
	        messageHolder.sendDebugMessage('pick from creative');
	        preslot = player.getSwappableHotbarSlot();
	        clientJava.interactionManager.clickCreativeStack(Java.valueOf(ItemStack.of(Material.of("netherite_pickaxe"))), Java.intOf(36 + preslot));
	        player.setSelectedSlot(preslot);
	        return true;
	    }
	}
	return false;
}
fun checkPickaxe(){
    if(player.getGamemode() == 'creative'){
        return true;
    }
    if (player.getItemForSlot(player.getCurrentSlot() + 36).getId().contains("pickaxe")){
        return true;
    }
	slot = player.getSlotFor(ItemStack.of(Material.of("diamond_pickaxe")));
	if (slot == null) {
		slot = player.getSlotFor(ItemStack.of(Material.of("netherite_pickaxe")));
	}
	if (slot != null) {
		if (0 <= slot-36 && slot-36  <= 8) {
		    return true;
		}
		else {
			preslot = player.getSwappableHotbarSlot();
			return true;
		}
	}
	messageHolder.sendMessage("Can't find pickaxe in inventory");
	return false;
}
fun assertItem(itemString){
    swapToItem(itemString);
    return player.getItemForSlot(player.getCurrentSlot() + 36).getId() == itemString;
}

fun assertTool(){
    swapToPickaxe();
    return player.getItemForSlot(player.getCurrentSlot() + 36).getId().contains('pickaxe');
}
fun breakBlock(pos, requireSneak){
	if (world.getBlockAt(pos).getHardness() == -1 || world.getBlockAt(pos).isFluid() || world.isAir(pos)) {
	    return;
	}
	if (world.getBlockAt(pos).getHardness() == 0 && !world.getBlockAt(pos).isReplaceable()) {
	    player.attackBlock(pos,'up');
	    return;
	}
	if (!world.getBlockAt(pos).isReplaceable() ) {
	    assertTool();
        if (isBlockInstantBreakable(pos)){
            player.attackBlock(pos,'up');
            return;
        }
	    while(!world.getBlockAt(pos).isReplaceable()) {
	    	sleep(50);
	    	if (requireSneak) {player.setSneaking(true);}
	    	player.updateBreakingBlock(pos);
	    	if(world.getBlockAt(pos).isReplaceable()){break;}
	    }
	}
}
fun isBlockInstantBreakable(pos){
    //assume pickaxe
    b = world.getBlockAt(pos);
    return player.getBlockBreakingSpeed(b) >= 1;
}
fun getReverse(dir) {
    dir = dir.uppercase();
    if (dir == "UP") {
        return "DOWN";
    }
    if (dir == "DOWN") {
        return "UP";
    }
    if (dir == "EAST") {
        return "WEST";
    }
    if (dir == "WEST") {
        return "EAST";
    }
    if (dir == "NORTH") {
        return "SOUTH";
    }
    if (dir == "SOUTH") {
        return "NORTH";
    }
    return null;
}

//Simple carpet protocol
fun applyCarpetProtocol(x,y,z,direction){
    if (direction == null) {return [x,y,z];}
	dirId = getDirectionId(direction);
	return [x+2*dirId + 2, y, z];
}
fun getDirectionId(dir) {
    dir = dir.fromString.uppercase();
    if (dir == "UP") {
        return 1;
    }
    if (dir == "DOWN") {
        return 0;
    }
    if (dir == "EAST") {
        return 5;
    }
    if (dir == "WEST") {
        return 4;
    }
    if (dir == "NORTH") {
        return 2;
    }
    if (dir == "SOUTH") {
        return 3;
    }
    return null;
}
fun placeTorch(blockPos, itemString){
	assertItem(itemString);
	if (assertItem(itemString) || trustClient){
	    x = blockPos.getX();
	    y = blockPos.getY();
	    z = blockPos.getZ();
	    player.interactBlock(x,y,z,"up",x,y-1,z,false);
	    return true;
	}
	return false;
}
fun placeWallTorch(blockPos, itemString, torchFacing){
    clickPos = blockPos.offset(torchFacing.getOpposite());
    if (!world.getBlockAt(clickPos.getX(),clickPos.getY(),clickPos.getZ()).sideCoversSmallSquare(torchFacing.fromString)){
        messageHolder.sendMessage("position "+ clickPos.formatted() + ' does not handle wall torch.');
        return false;
    }
	assertItem(itemString);
	if (assertItem(itemString) || trustClient){
	    clickVec = clickPos.getSidePos(torchFacing);
	    player.interactBlock( clickVec.getX(), clickVec.getY(), clickVec.getZ(),torchFacing.fromString,clickPos.getX(),clickPos.getY(),clickPos.getZ(),false);
	    messageHolder.sendDebugMessage(clickPos.formatted() + ' '+ clickVec.formatted());
	    return true;
	}
	return false;
}
fun requiredOffsetCheck(blockPos, itemString, torchFacing){
    //WallMountedBlock, we need library maybe?
    if (torchFacing == null){
        torchFacing = new Direction("down");
    }
    if (itemString.contains('torch') && torchFacing.axis != 'Y'){
        clickPos = blockPos.offset(torchFacing.getOpposite());
        if (!world.getBlockAt(clickPos.getX(),clickPos.getY(),clickPos.getZ()).sideCoversSmallSquare(torchFacing.fromString)){
            return false;
        }
    }
    else {
        return checkCanPlaceAt(blockPos, ItemStack.of(Material.of(itemString)).asBlock());
    }
    return true;
}
fun getLookRefYawPitchDirection(itemString,direction){
    if (itemString.contains('torch')){
        return null;
    }
    fy = 0;
    fp = 0;
    lookRefDir = 'north';
	if (direction != null) {
	    dir = direction.fromString.uppercase();
	    lookRefdir = dir;
	    if (itemString.contains("piston") || itemString.contains("repeater")){
	    	lookRefdir = getReverse(dir); //well actually, we might need to have testing function
	    }
	    fy = player.getYaw();
	    fp = player.getPitch();
	    if (lookRefdir  == "UP") {
	    	fy = 0;
	    	fp = -90;
	    }
	    else if (lookRefdir  == "DOWN") {
	    	fy = 0;
	    	fp = 90;
	    }
	    else if (lookRefdir  == "EAST") {
	    	fy = -90;
	    	fp = 0;
	    }
	    else if (lookRefdir  == "WEST") {
	    	fy = 90;
	    	fp = 0;
	    }
	    else if (lookRefdir  == "NORTH") {
	    	fy = 180;
	    	fp = 0;
	    }
	    else if (lookRefdir  == "SOUTH") {
	    	fy = 0;
	    	fp = 0;
	    }
	    return [fy, fp, lookRefDir];
	}
	else {
	    return null;
	}
}
fun placeDirectionBlock(blockPos,itemString,direction, immediate){
    if(itemString.contains('torch')){
        if (direction.axis == "Y")
            return placeTorch(blockPos, itemString);
        else {
            return placeWallTorch(new PosWithFun(blockPos), itemString, direction);
        }
    }
    fy = 0;
    fp = 0;
    lookRefdir = 'north';

	if (direction != null) {
	    dir = direction.fromString.uppercase();
	    lookRefdir = dir;
	    if (itemString.contains("piston") || itemString.contains("repeater")){
	    	lookRefdir = getReverse(dir); //well actually, we might need to have testing function
	    }
	    fy = player.getYaw();
	    fp = player.getPitch();
	    if (lookRefdir  == "UP") {
	    	fy = 0;
	    	fp = -90;
	    }
	    else if (lookRefdir  == "DOWN") {
	    	fy = 0;
	    	fp = 90;
	    }
	    else if (lookRefdir  == "EAST") {
	    	fy = -90;
	    	fp = 0;
	    }
	    else if (lookRefdir  == "WEST") {
	    	fy = 90;
	    	fp = 0;
	    }
	    else if (lookRefdir  == "NORTH") {
	    	fy = 180;
	    	fp = 0;
	    }
	    else if (lookRefdir  == "SOUTH") {
	    	fy = 0;
	    	fp = 0;
	    }
	}
	assertItem(itemString);
	if (assertItem(itemString) || trustClient){
	    x = blockPos.getX();
	    y = blockPos.getY();
	    z = blockPos.getZ();
	    py = y;
	    if ((direction != null && !accurateBlockPlacement) || itemString.contains("rail")) {
	    	player.fakeLook(fy,fp,lookRefdir,1);
	    	if (!immediate){
	    	    sleep(50);
	    	}
	    	player.interactBlock(x,py,z,lookRefdir,x,y,z,false);
	    	if (itemString.contains("rail")){
	    	    if (!immediate){
	    	        sleep(50);
	    	    }
	    	}
	    } else if (direction != null && accurateBlockPlacement){
	    	carpetVec = applyCarpetProtocol(x,y,z,direction);
	    	hx = carpetVec.get(0);
	    	hy = carpetVec.get(1);
	    	hz = carpetVec.get(2);
	    	player.interactBlock(hx,hy,hz,direction.fromString,x,py,z,true);
	    }
	    else {
            player.interactBlock(x,y,z,"north",x,y,z,false);
	    }
	    return true;
	}
	else {
	    return false;
	}
}
fun matchProperty(blockPos,blockId, propertyMap){
    //matches blockState with property
    cblock = world.getBlockAt(blockPos.asPos());
    if (cblock.getId() != blockId){
        return false;
    }
    mapping = cblock.getBlockProperties();
    foreach ( properties : propertyMap.getKeys()){
        if (propertyMap.get(properties) != mapping.get(properties)){
            return false;
        }
    }
    return true;
}
//Functions that generates Objects because there is no class A extends B in arucas
//Sensei you got more work!


//generated observingTask that executes with observed Position block has desired block, and properties.

fun observingTask(blockPos,shouldBreak, itemString, facing, observePos, blockId, propertyMap){
    predicate = fun (){return matchProperty(observePos, blockId, propertyMap);};
    if (shouldBreak){
        return new WaitingTask(blockPos, predicate);
    }
    else {
        return new WaitingTask(blockPos, itemString, facing, predicate);
    }
    return null;
}
//Piston removal when it extends.
fun pistonExtendRemovalTask(blockPos, facing){
    shouldBreak = true;
    itemString = 'piston';
    observePos = blockPos;
    blockId = 'piston';
    propertyMap = {'extended' : true};
    return observingTask(blockPos,true, itemString, facing, observePos, blockId, propertyMap);
}
fun pistonExtendRemovalTask(blockPos, facing, observePos){
    shouldBreak = true;
    propertyMap = {'extended' : true};
    return observingTask(blockPos,true, 'piston', facing, observePos, 'piston', propertyMap);
}
fun pistonHeadFindingPredicate(blockPos, facing){
    return fun(){return world.getBlockAt(blockPos.offset(facing).asPos()).getId() == 'piston_head';};
}
fun pistonRetractFindingPredicate(blockPos, facing){
    return fun(){return world.getBlockAt(blockPos.offset(facing).asPos()).getId() == 'moving_piston';};
}
//Piston placement when A extends then B executes
// We place piston in pos A, with torch at pos B, then wait until it 'extends'. if moving piston is found, remove torch first then piston, and replace (torch - optional) then piston with new direction. pt-tp-tp
//
fun chainedPistonTaskFull(blockPos, facing1, facing2, torchPos,torchPos2, torchFacing,torchFacing2, headless){
    iter = new SequencedTaskIterator();
    task1 = new Task(blockPos, 'piston', facing1); //place piston
    if (!accurateBlockPlacement){
        fy, fp, requiredDirection = getLookRefYawPitchDirection('piston',facing2);
        iter.addAction(new FakeLookWaitingTask(fy, fp, requiredDirection, fun () {return task1.isExecuted;}));
    }
    task2 = new Task(torchPos, 'redstone_torch', torchFacing); //place torch
    //optional slime block placement.
    task3 = new WaitingTask(torchPos, pistonHeadFindingPredicate(blockPos, facing1)); //break torch
    task3.setImmediate(true);
    torchRemovePredicate = fun(){return task3.isExecuted;};
    task4 = null;
    if (headless){
        task6 = new WaitingTask(torchPos2, 'redstone_torch', torchFacing2, torchRemovePredicate);//we use secondary position that prevents desync
        task4FinishPredicate = fun(){return task6.isExecuted;};
        task6.setImmediate(true);
        task4 = new WaitingTask(blockPos, fun(){return task6.isExecuted;}); //remove piston
        task4FinishPredicate = fun(){return task4.isExecuted;}; //check if done
        task4.setImmediate(true);
        task5 = new WaitingTask(blockPos, 'piston', facing2, task4FinishPredicate); //place piston
        task5.setImmediate(true);
        iter.addAction(task1);
        iter.addAction(task2);
        iter.addAction(task3);
        iter.addAction(task4);
        iter.addAction(task6);
        iter.addAction(task5);
    }
    else {
        task4 = new WaitingTask(blockPos, torchRemovePredicate); //remove piston
        task4FinishPredicate = fun(){return task4.isExecuted;}; //check if done
        task4.setImmediate(true);
        task5 = new WaitingTask(blockPos, 'piston', facing2, task4FinishPredicate); //place piston
        task5.setImmediate(true);
        iter.addAction(task1);
        iter.addAction(task2);
        iter.addAction(task3);
        iter.addAction(task4);
        iter.addAction(task5);
    }
    return iter;
}
fun chainedPistonTaskRecord(record, headless){
    facing1 = record.pistonFacing;
    facing2 = record.finalFacing;
    torchFacing = record.torchFacing;
    torchPos = record.torchPos;
    pistonPos = record.pistonPos;
    iter = new SequencedTaskIterator();
    task1 = new Task(pistonPos, 'piston', facing1); //place piston
    if (!accurateBlockPlacement){
        fy, fp, requiredDirection = getLookRefYawPitchDirection('piston',facing2);
        iter.addAction(new FakeLookWaitingTask(fy, fp, requiredDirection, fun () {return task1.isExecuted;}));
    }
    task2 = new Task(torchPos, 'redstone_torch', torchFacing); //place torch
    //optional slime block placement.
    task3 = new WaitingTask(torchPos, pistonHeadFindingPredicate(pistonPos, facing1)); //break torch
    task3.setImmediate(true);
    torchRemovePredicate = fun(){return task3.isExecuted;};
    task4 = null;
    if (headless){
        task6 = new WaitingTask(torchPos, 'redstone_torch', torchFacing, torchRemovePredicate);//we use secondary position that prevents desync
        task4FinishPredicate = fun(){return task6.isExecuted;};
        task6.setImmediate(true);
        task4 = new WaitingTask(pistonPos, fun(){return task6.isExecuted;}); //remove piston
        task4FinishPredicate = fun(){return task4.isExecuted;}; //check if done
        task4.setImmediate(true);
        task5 = new WaitingTask(pistonPos, 'piston', facing2, task4FinishPredicate); //place piston
        task5.setImmediate(true);
        iter.addAction(task1);
        iter.addAction(task2);
        iter.addAction(task3);
        iter.addAction(task4);
        iter.addAction(task6);
        iter.addAction(task5);
    }
    else {
        task4 = new WaitingTask(pistonPos, torchRemovePredicate); //remove piston
        task4FinishPredicate = fun(){return task4.isExecuted;}; //check if done
        task4.setImmediate(true);
        task5 = new WaitingTask(pistonPos, 'piston', facing2, task4FinishPredicate); //place piston
        task5.setImmediate(true);
        iter.addAction(task1);
        iter.addAction(task2);
        iter.addAction(task3);
        iter.addAction(task4);
        iter.addAction(task5);
    }
    return iter;
}
fun chainedPistonTaskBreak(blockPos, facing1, facing2, torchPos, torchFacing){ //same pos, breaks block
    iter = new SequencedTaskIterator();
    task1 = new Task(blockPos, 'piston', facing1); //place piston
    task2 = new Task(torchPos, 'redstone_torch', torchFacing); //place torch
    //optional slime block placement.
    task3 = new WaitingTask(torchPos, pistonHeadFindingPredicate(blockPos, facing1)); //break torch
    task3.setImmediate(true);
    torchRemovePredicate = fun(){return task3.isExecuted;};
    task4 = null;
    task4 = new WaitingTask(blockPos, torchRemovePredicate); //remove piston
    task4FinishPredicate = fun(){return task4.isExecuted;}; //check if done
    task4.setImmediate(true);
    task5 = new WaitingTask(blockPos, 'piston', facing2, task4FinishPredicate); //place piston
    task5.setImmediate(true);
    iter.addAction(task1);
    iter.addAction(task2);
    iter.addAction(task3);
    iter.addAction(task4);
    iter.addAction(task5);
    return iter;
}
fun chainedPistonTaskSelect(blockPos, facing1, facing2, torchPos, torchFacing, headless){ //same pos but with headless selection
    iter = new SequencedTaskIterator();
    task1 = new Task(blockPos, 'piston', facing1); //place piston
    task2 = new Task(torchPos, 'redstone_torch', torchFacing); //place torch
    //optional slime block placement.
    task3 = new WaitingTask(torchPos, pistonHeadFindingPredicate(blockPos, facing1)); //break torch
    task3.setImmediate(true);
    torchRemovePredicate = fun(){return task3.isExecuted;};
    task4 = null;
    if (headless){
        task6 = new WaitingTask(torchPos, 'redstone_torch', torchFacing, torchRemovePredicate);//we use secondary position that prevents desync
        task4FinishPredicate = fun(){return task6.isExecuted;};
        task6.setImmediate(true);
        task4 = new WaitingTask(blockPos, fun(){return task6.isExecuted;}); //remove piston
        task4FinishPredicate = fun(){return task4.isExecuted;}; //check if done
        task4.setImmediate(true);
        task5 = new WaitingTask(blockPos, 'piston', facing2, task4FinishPredicate); //place piston
        task5.setImmediate(true);
        iter.addAction(task1);
        iter.addAction(task2);
        iter.addAction(task3);
        iter.addAction(task4);
        iter.addAction(task6);
        iter.addAction(task5);
    }
    else {
        task4 = new WaitingTask(blockPos, torchRemovePredicate); //remove piston
        task4FinishPredicate = fun(){return task4.isExecuted;}; //check if done
        task4.setImmediate(true);
        task5 = new WaitingTask(blockPos, 'piston', facing2, task4FinishPredicate); //place piston
        task5.setImmediate(true);
        iter.addAction(task1);
        iter.addAction(task2);
        iter.addAction(task3);
        iter.addAction(task4);
        iter.addAction(task5);
    }
    return iter;
}

//classes
class DefaultedMap {
    var map;
    var defaultValue = null;
    DefaultedMap(items){
        this.map = {};
        foreach (item : items){
            this.map.put(item, this.defaultValue);
        }
    }
    DefaultedMap(items, defaultValue){
        this.map = {};
        this.defaultValue = defaultValue;
        foreach (item : items){
            this.map.put(item, this.defaultValue);
        }
    }
    fun getValues(){
        return this.map.getValues();
    }
    fun containsKey(key){
        return this.map.conatinsKey();
    }
    fun putAll(other){
        this.map.putAll(other);
    }
    fun addList(other){
        this.map.putAll(new DefaultedMap(other).map);
    }
    fun get(key){
        return this.map.get(key);
    }
    fun isEmpty(){
        return this.map.isEmpty();
    }
    fun clear(){
        this.map.clear();
    }
    fun toString(){
        return this.map.toString();
    }
    fun getKeys(){
        return this.map.getKeys();
    }
    fun putIfAbsent(key, value){
        return this.map.putIfAbsent(key, value);
    }
    fun remove(key){
        if (key == null){
            return null;
        }
        return this.map.remove(key);
    }
    fun put(key, value){
        return this.map.put(key, value);
    }
    fun put(key){
        return this.map.put(key, this.defaultValue);
    }
    fun poll(){
        if (!this.isEmpty())
            return this.map.getKeys().get(0);
    }
}
class MessageHolder{
    //message holding class that prevents spamming same message
    var stringSet;
    var debugFlag;
    var previousMessage ;
    MessageHolder(){
        this.stringSet = Set.of();
    }
    fun sendMessage(message){
        if(this.previousMessage == message){
            return;
        }
        player.message(message);
        this.stringSet.add(message);
        this.previousMessage = message;
    }
    fun sendMessageUnique(message){
        if (this.stringSet.contains(message)){
            return;
        }
        player.message(message);
        this.stringSet.add(message);
    }
    fun sendMessageUnchecked(message){
        player.message(message);
        this.stringSet.add(message);
    }
    fun sendDebugMessage(message){
        if (this.debugFlag && !hideMessage){
            this.sendMessage(message);
        }
    }
}
class ClickTask {
    //instantly calculate difference and click
    var blockPos;
    var wantedStateProperty = {}; //Noteblock : note, repeater - delay, comparator - mode, redstone dust : east(for example)
    ClickTask(blockPos, stateProperty){
        this.blockPos = blockPos;
        this.wantedStateProperty = stateProperty; //Map of properties
    }
    ClickTask(blockPos){
        this.blockPos = blockPos;
        this.wantedStateProperty = {'delay' : 1, 'mode' : 'compare', 'east' : 'side', 'note' : 0}; //Map of properties
    }
    fun repeaterStatus(){
        clientDelay = world.getBlockAt(this.blockPos.asPos()).getBlockProperties().get('delay');
        if(clientDelay == null){
            return 0;
        }
        messageHolder.sendDebugMessage(this.blockPos.formatted() + ' has wrong delay, could be desync?');
        return Math.mod(this.wantedStateProperty.get('delay') - clientDelay, 4);
    }
    fun comparatorStatus(){
        clientMode = world.getBlockAt(this.blockPos.asPos()).getBlockProperties().get('mode');
        if (clientMode == null || clientMode == this.wantedStateProperty.get('mode')){
            return 0;
        }
        messageHolder.sendDebugMessage(this.blockPos.formatted() + ' has wrong mode, could be desync?');
        return 1;
    }
    fun dustStatus(){
        clientConnected = world.getBlockAt(this.blockPos.asPos()).getBlockProperties().get('east');
        if (clientConnected == null || clientConnected == this.wantedStateProperty.get('east')){
            return 0;
        }
        messageHolder.sendDebugMessage(this.blockPos.formatted() + ' has wrong dust shape, could be desync?');
        return 1;
    }
    fun noteBlockStatus(){
        clientNote = world.getBlockAt(this.blockPos.asPos()).getBlockProperties().get('note');
        if(clientNote == null){
            return 0;
        }
        messageHolder.sendDebugMessage(this.blockPos.formatted() + ' has wrong note, could be desync?');
        return Math.mod(this.wantedStateProperty.get('note') - clientNote, 25);
    }
    fun fix(){
        clickTimes = this.repeaterStatus() + this.comparatorStatus() + this.dustStatus() + this.noteBlockStatus();
        for (i = 0; i < clickTimes; i++) {
            player.interactBlock(this.blockPos.asPos(), "up");
            sleep(16);
        }

    }
}
class Task {
    // task that has what to do, break / item with directions
    var pos;
    var shouldBreak;
    var item;
    var block; //item.asBlock()
    var facing;
    var itemString;
    var optional = 0;
    var connectedTask = null;
    var isExecuted = false;
    var withBlockState;
    var immediate = false;
    var predicate = fun (){return true;};
    Task(pos, itemName, direction){
        this.pos = new PosWithFun(pos);
        this.shouldBreak = false;//ItemStack.of(Material.of(itemName)).asBlock();
        this.item = ItemStack.of(Material.of(itemName));
        this.block = this.item.asBlock();
        this.itemString = itemName;
        this.facing = direction;
    }
    Task(pos){
        this.pos = new PosWithFun(pos);
        this.shouldBreak = true;
        this.item = null;
        this.facing = null;
    }
    Task(pos, b, i, f){
        this.pos = new PosWithFun(pos);
        this.shouldBreak = b;
        if (Type.of(i).getName() == 'String'){
            i = ItemStack.of(Material.of(i));
        }
        this.item = i;
        this.itemString = i.getId();
        this.block = i.asBlock();
        this.facing = f;
    }
    Task(pos, b, i, f, optional){
        this.pos = new PosWithFun(pos);
        this.shouldBreak = b;
        this.item = i;
        this.itemString = i.getId();
        this.block = i.asBlock();
        this.facing = f;
        this.optional = optional;
    }
    fun add(otherPos){
        return new Task(this.pos.add(otherPos), this.shouldBreak, this.item, this.facing);
    }
    fun hash(){
        return '' + this.pos + this.shouldBreak + this.itemString + this.facing;
    }
    fun isDone(){
    // null returns for nothing required
        pos = this.pos.asPos();
        clientBlock = world.getBlockAt(pos);
        if (this.shouldBreak && clientBlock.isReplaceable()){
            //break task, finished
            this.isExecuted = true;
            return null;
        }
        else if (this.shouldBreak && !clientBlock.isReplaceable()) {
            if (this.isExecuted && trustClient){
                return null;
            }
            return this;
        }
        else if (!this.shouldBreak && clientBlock.isReplaceable()){
            //place task, but empty
            if (this.isExecuted && trustClient){
                return null;
            }
            return this;
        }
        state = clientBlock;
        if (state.getId() != this.block.getId()){
            //wall torch exceptions
            if (state.getId().contains('wall')){
                this.isExecuted = true;
                return null;
            }
            if (this.connectedTask != null && trustClient && this.connectedTask.isExecuted){
                return null;
            }
            //place task, but break first
            this.connectedTask = new Task(this.pos);
            return this.connectedTask;
        }
        //if (this.facing != null && state.getBlockProperties().get('facing') != this.facing){
        //    return new Task(this.pos);
        //}
        return null;
    }
    fun internalAssertItem(){
        if (this.shouldBreak){
            if (isBlockInstantBreakable(this.pos.asPos())){
                return true;
            }
            return assertTool();
        }
        return assertItem(this.itemString);
    }
    fun checkInventory(){
        if (this.shouldBreak){
            return checkPickaxe();
        }
        return checkItem(this.itemString);
    }
    fun internalCanProcess(){
        if (this.pos.isNear(player, playerReach)){
         if (trustClient || this.internalAssertItem())
            return true;
        }
        return false;
        //returns if player has item or tool and reach
    }
    fun isAvailable(){
        return this.pos.isNear(player, playerReach) && this.checkInventory() && (this.shouldBreak || requiredOffsetCheck(this.pos, this.itemString, this.facing)) ;
    }
    fun process(){
    // checks, returns if processed
        if (this.internalCanProcess()){
            if(!this.isImmediate()){
                sleep(taskInterval);
            }
            else {
                sleep(immediateInterval);
            }
            if (!hideMessage)
                messageHolder.sendDebugMessage(this.formatted());
            if (this.shouldBreak){
                breakBlock(this.pos.asPos(), carefulBreakSneak);
                this.isExecuted = true;
                messageHolder.sendDebugMessage(this.formattedSuccess());
                return true;
            }
            result = placeDirectionBlock(this.pos.asPos(),this.itemString,this.facing, this.isImmediate());
            if (result){
                this.isExecuted = true;
                messageHolder.sendDebugMessage(this.formattedSuccess());
                return true;
            }
            else {
                messageHolder.sendMessage(this.formattedError());
            }

        }
        return false;
    }
    fun finish(){
        while (true){
        messageHolder.sendDebugMessage(this.formatted());
            pendingTask = this.isDone();
            if (pendingTask != null){
                if (!pendingTask.checkInventory()){
                    messageHolder.sendMessage(pendingTask.formattedError());
                    break;
                }
                result = pendingTask.process();
                if (result){
                    if (trustClient){
                        if (this != pendingTask){
                            if (!pendingTask.checkInventory()){
                                messageHolder.sendMessage(this.formattedError());
                                break;
                            }
                            this.process();
                        }
                        break;
                    }
                    else {
                        sleep(serverPing);
                    }

                }
            }
            else {
                break;
            }
        }
    }
    fun isImmediate(){
        return this.immediate;
    }
    fun setImmediate(bool){
        this.immediate = bool;
    }
    fun formattedError(){
        if (this.shouldBreak){
            return 'failed to break block at '+ this.pos.formatted();
        }
        return 'failed to place ' + this.itemString + ' at ' + this.pos.formatted();
    }
    fun formatted(){
        if (this.shouldBreak){
            return 'break block at '+ this.pos.formatted();
        }
        return 'place ' + this.itemString + ' at ' + this.pos.formatted();
    }
    fun formattedSuccess(){
        if (this.shouldBreak){
            return 'broke block at '+ this.pos.formatted()+ ' at' + getMilliTime();
        }
        return 'placed ' + this.itemString + ' at ' + this.pos.formatted()+ ' at' + getMilliTime();
    }
    fun copy(){
        return new Task(this.pos.copy(), this.shouldBreak, this.item, this.facing, this.optional + 1);
    }
}
class FakeLookWaitingTask{
    var fy;
    var fp;
    var direction;
    var predicate = fun(){return true;};
    var immediate = true;
    var isExecuted = false;
    FakeLookWaitingTask(fy, fp, direction, predicate){
        this.fy = fy;
        this.fp = fp;
        this.direction = direction;
        this.predicate = predicate;
    }
    fun isDone(){
        if (this.isExecuted){
            return null;
        }
        return this;
    }
    fun internalCanProcess(){
        return this.predicate();
    }
    fun isAvailable(){
        return this.predicate();
    }
    fun process(){
        if (this.internalCanProcess()){
            player.fakeLook(this.fy, this.fp, this.direction, 1);
            this.isExecuted = true;
            return true;
        }
        return false;
    }
    fun finish(){
        return this.process();
    }
    fun isImmediate(){
        return this.immediate;
    }
}
class WaitingTask {
    // Task with predicate check to execute, such as block observe
    var pos;
    var shouldBreak;
    var item;
    var block; //item.asBlock()
    var facing;
    var itemString;
    var optional = 0;
    var connectedTask = null;
    var isExecuted = false;
    var withBlockState;
    var predicate = fun (){return true;};
    var immediate = false;
    WaitingTask(pos, itemName, direction, predicate){
        this.pos = new PosWithFun(pos);
        this.shouldBreak = false;
        this.item = ItemStack.of(Material.of(itemName));
        this.block = this.item.asBlock();
        this.itemString = itemName;
        this.facing = direction;
        this.predicate = predicate;
    }
    WaitingTask(pos, predicate){
        this.pos = new PosWithFun(pos);
        this.shouldBreak = true;
        this.item = null;
        this.facing = null;
        this.predicate = predicate;
    }
    WaitingTask(pos, b, i, f, predicate){
        this.pos = new PosWithFun(pos);
        this.shouldBreak = b;
        if (Type.of(i).getName() == 'String'){
            i = ItemStack.of(Material.of(i));
        }
        this.item = i;
        this.itemString = i.getId();
        this.block = i.asBlock();
        this.facing = f;
        this.predicate = predicate;
    }
    WaitingTask(pos, b, i, f,predicate, optional){
        this.pos = new PosWithFun(pos);
        this.shouldBreak = b;
        this.item = i;
        this.itemString = i.getId();
        this.block = i.asBlock();
        this.facing = f;
        this.optional = optional;
        this.predicate = predicate;
    }
    fun isImmediate(){
        return this.immediate;
    }
    fun setImmediate(bool){
        this.immediate = bool;
    }
    fun add(otherPos){
        return new WaitingTask(this.pos.add(otherPos), this.shouldBreak, this.item, this.facing, this.predicate);
    }
    fun hash(){
        return '' + this.pos + this.shouldBreak + this.itemString + this.facing;
    }
    fun isDone(){
    // null returns for nothing required
        if(this.isExecuted){
            return null;
        }
        return this;
    }
    fun internalAssertItem(){
        if (this.shouldBreak){
            if (isBlockInstantBreakable(this.pos.asPos())){
                return true;
            }
            return assertTool();
        }
        return assertItem(this.itemString);
    }
    fun checkInventory(){
        if (this.shouldBreak){
            return checkPickaxe();
        }
        return checkItem(this.itemString);
    }
    fun internalCanProcess(){
        if (this.pos.isNear(player, playerReach) && this.predicate()){
         if (trustClient || this.internalAssertItem())
            return true;
        }
        return false;
        //returns if player has item or tool and reach
    }
    fun isAvailable(){
        //external access
        if (this.isImmediate()){
            return this.predicate();
        }
        return this.pos.isNear(player, playerReach) && this.checkInventory() && (this.shouldBreak || requiredOffsetCheck(this.pos, this.itemString, this.facing)) && this.predicate() ;
    }
    fun process(){
    // checks, returns if processed
        if (this.internalCanProcess()){
            if(trustClient){
                this.internalAssertItem();
            }
            if (!this.immediate){
                sleep(taskInterval);
            }
            else {
                sleep(immediateInterval);
            }
            messageHolder.sendDebugMessage(this.formatted());
            if (this.shouldBreak){
                breakBlock(this.pos.asPos(), carefulBreakSneak);
                this.isExecuted = true;
                messageHolder.sendDebugMessage(this.formattedSuccess());
                return true;
            }

            result = placeDirectionBlock(this.pos.asPos(),this.itemString,this.facing, this.isImmediate());
            if (result){
                this.isExecuted = true;
                messageHolder.sendDebugMessage(this.formattedSuccess());
                return true;
            }
            else {
                messageHolder.sendMessage(this.formattedError());
            }

        }
        return false;
    }
    fun finish(){
        while (true){
            messageHolder.sendDebugMessage(this.formatted());
            pendingTask = this.isDone();
            if (pendingTask != null){
                if (!pendingTask.checkInventory()){
                    messageHolder.sendMessage(pendingTask.formattedError());
                    break;
                }
                result = pendingTask.process();
                if (result){
                    if (trustClient){
                        if (this != pendingTask){
                            if (!pendingTask.checkInventory()){
                                messageHolder.sendMessage(this.formattedError());
                                break;
                            }
                            this.process();
                        }
                        break;
                    }
                    else {
                        sleep(serverPing);
                    }

                }
            }
            else {
                break;
            }
        }
    }
    fun formattedError(){
        if (this.shouldBreak){
            return 'failed to break block at '+ this.pos.formatted();
        }
        return 'failed to place ' + this.itemString + ' at ' + this.pos.formatted() + ' with predicate';
    }
    fun formatted(){
        if (this.shouldBreak){
            return 'break block at '+ this.pos.formatted();
        }
        return 'place ' + this.itemString + ' at ' + this.pos.formatted()+ ' with predicate';
    }
    fun formattedSuccess(){
        if (this.shouldBreak){
            return 'broke block at '+ this.pos.formatted() + ' at' + getMilliTime();
        }
        return 'placed ' + this.itemString + ' at ' + this.pos.formatted()+ ' with predicate at '+ getMilliTime();
    }
    fun copy(){
        return new WaitingTask(this.pos.copy(), this.shouldBreak, this.item, this.facing,this.predicate, this.optional + 1);
    }
}
class CyclicTaskGenerator {
    var previousTask = null;
    var currentTask = null;
    var nextTask = null;
    var ListOfTask;
    var blockPos;
    var pointer;
    var length;
    var blockSize;
    var cycle = 0;
    var mapping = null;
    //tasks : [PosWithFun(), shouldBreak, item, facing],....
    CyclicTaskGenerator(tasks, originPos){
        this.ListOfTask = tasks;
        this.blockPos = new PosWithFun(originPos);
        this.length = len(tasks);
        this.blockSize = this.preCalculateBlockSize();
        this.pointer = 0;
    }
    CyclicTaskGenerator(originPos){
        this.ListOfTask = [];
        this.blockPos = new PosWithFun(originPos);
        this.length = 0;
        this.blockSize = new PosWithFun(0,0,0);
        this.pointer = 0;
    }
    fun preCalculateBlockSize(){
        // get minX Y Z maxX Y Z
        minPos = new PosWithFun(0,0,0);
        maxPos = new PosWithFun(0,0,0);
        foreach(tasks : this.ListOfTask){
            minPos = minPos.getMinPos(tasks.pos);
            maxPos = maxPos.getMaxPos(tasks.pos);
        }
        return maxPos.subtract(minPos).add(new PosWithFun(1,1,1));
    }
    fun poll(){
        this.previousTask = this.currentTask;
        if (this.pointer == this.length){
            this.pointer = 0;
            this.cycle ++;
        }
        //position
        this.currentTask = this.ListOfTask.get(this.pointer).add(this.blockPos.add(this.blockSize.mult(this.cycle)));
        this.pointer++;
        return this.currentTask;
    }
    fun pollSafely(){
        //returns null if its okay, task if it should do something
        pendingTask = null;
        if (this.previousTask != null){
            pendingTask = this.previousTask.isDone();
            new ClickTask(this.previousTask.pos).fix();
        }
        else {
            pendingtask = null;
        }
        if (pendingTask == null){
            return this.poll();
        }
        return pendingTask;
    }
    fun execute(){
        awaitingTask = this.pollSafely();
        if (awaitingTask != null)
            awaitingTask.finish();
    }
    fun addAction(position, itemstring, direction, shouldBreak){
        if(this.mapping != null){
            if(this.mapping.get(itemstring) != null){
                itemstring = this.mapping.get(itemstring);
            }
        }
        this.length ++;
        this.ListOfTask.append(new Task(new PosWithFun(position), shouldBreak, itemstring, direction));
    }
    fun adjustOrigin(newOrigin){
        this.blockPos = new PosWithFun(newOrigin);
    }
    fun attachMapping(mapping){
        this.mapping = mapping;
    }
    fun getDiagonal(direction){
        blockPos = new PosWithFun(0,0,0);
        this.mapping = Mapping_Diagonal;
        if (this.mapping != null){
            yClockwise = direction.rotateYClockwise();
            this.addAction(blockPos.offset(direction).offset(yClockwise).offset(direction), 0, yClockwise, false); //place rail
            this.addAction(blockPos.offset(direction).offset(yClockwise).offset(yClockwise), 0, yClockwise, false);
            this.addAction(blockPos.offset(direction).offset(yClockwise), 0, yClockwise, false);//place rail
            this.addAction(blockPos.offset(direction).offset(yClockwise).offset(direction), 0, yClockwise, true); //break rail
            this.addAction(blockPos.offset(direction).offset(yClockwise).offset(yClockwise), 0, yClockwise, true);//break rail
            this.addAction(blockPos.offset(direction).offset(yClockwise).offset(direction,2), 7, yClockwise, false); //block for pushing
            this.addAction(blockPos.offset(direction).offset(yClockwise).offset(yClockwise,2), 7, yClockwise, false); //block for pushing
            this.addAction(blockPos.offset(direction).offset(yClockwise).offset(direction,3), 3, yClockwise, false); //piston
            this.addAction(blockPos.offset(direction).offset(yClockwise).offset(yClockwise,3), 3, direction, false); //piston
            this.addAction(blockPos.offset(direction).offset(yClockwise).offset(direction,4), 4, yClockwise, false); //powerable
            this.addAction(blockPos.offset(direction).offset(yClockwise).offset(yClockwise,4), 4, yClockwise, false); //powerable
            this.addAction(blockPos.offset(direction).offset(yClockwise).offset(direction,5), 2, direction.getOpposite(), false); //repeater
            this.addAction(blockPos.offset(direction).offset(yClockwise).offset(yClockwise,5), 2, yClockwise.getOpposite(), false);; //repeater
            this.addAction(blockPos.offset(direction).offset(yClockwise).offset(direction,6), 4, yClockwise, false); //powerable
            this.addAction(blockPos.offset(direction).offset(yClockwise).offset(yClockwise,6), 4, yClockwise, false); //powerable
            this.addAction(blockPos.offset(direction,2).offset(yClockwise,2).offset(direction), 0, yClockwise, false); //place rail
            this.addAction(blockPos.offset(direction,2).offset(yClockwise,2).offset(yClockwise), 0, yClockwise, false);//place rail
            this.addAction(blockPos.offset(direction,2).offset(yClockwise,2), 0, yClockwise, false);//place rail
            this.addAction(blockPos.offset(direction,2).offset(yClockwise,2).offset(direction), 0, yClockwise, true); //break rail
            this.addAction(blockPos.offset(direction,2).offset(yClockwise,2).offset(yClockwise), 0, yClockwise, true); //break rail
            this.addAction(blockPos.offset(direction,2).offset(yClockwise,2).offset(direction,2), 7, yClockwise, false); //block for pushing
            this.addAction(blockPos.offset(direction,2).offset(yClockwise,2).offset(yClockwise,2), 7, yClockwise, false); //block for pushing
            this.addAction(blockPos.offset(direction,2).offset(yClockwise,2).offset(direction,3), 3, yClockwise, false); //piston
            this.addAction(blockPos.offset(direction,2).offset(yClockwise,2).offset(yClockwise,3), 3, direction, false); //piston
            this.addAction(blockPos.offset(direction,2).offset(yClockwise,2).offset(direction,5), 6, direction, false); //dust
            this.addAction(blockPos.offset(direction,2).offset(yClockwise,2).offset(yClockwise,5), 6, direction, false); //dust
            this.addAction(blockPos.offset(direction).offset(yClockwise).offset(direction,3).up(), 5, DOWN, false); //carpet
            this.addAction(blockPos.offset(direction).offset(yClockwise).offset(yClockwise,3).up(), 5, DOWN, false); //carpet
            this.addAction(blockPos.offset(direction).offset(yClockwise).offset(direction,4).up(), 5, DOWN, false); //carpet
            this.addAction(blockPos.offset(direction).offset(yClockwise).offset(yClockwise,4).up(), 5, DOWN, false); //carpet
            this.addAction(blockPos.offset(direction).offset(yClockwise).offset(direction,6).up(), 5, DOWN, false); //carpet
            this.addAction(blockPos.offset(direction).offset(yClockwise).offset(yClockwise,6).up(), 5, DOWN, false); //carpet
            this.addAction(blockPos.offset(direction,2).offset(yClockwise,2).offset(direction,3).up(), 5, DOWN, false); //carpet
            this.addAction(blockPos.offset(direction,2).offset(yClockwise,2).offset(yClockwise,3).up(), 5, DOWN, false); //carpet
            this.blockSize = new PosWithFun(0,0,0).offset(direction, 2).offset(yClockwise,2);
            }
    }
    fun getStraightV1(direction){
            this.mapping = Mapping_Straight;
            blockPos = new PosWithFun(0,0,0);
            yClockwise = direction.rotateYClockwise();
            yCounterClockwise = direction.rotateYCounterclockwise();
            if (direction .equals( EAST) || direction .equals( SOUTH)) {
                    this.addAction(blockPos.offset(direction).offset(yClockwise), 0, yClockwise, false);//place rail
                    this.addAction(blockPos.offset(direction).offset(direction), 0, direction, false);//place rail
                    this.addAction(blockPos.offset(direction), 0, direction, false);//place rail
                    this.addAction(blockPos.offset(direction).offset(yClockwise), 0, yClockwise, true);//break rail
                    this.addAction(blockPos.offset(direction).offset(direction), 0, direction, true);//break rail
                    this.addAction(blockPos.offset(direction).offset(direction).offset(yCounterClockwise), 0, yCounterClockwise, false);//place rail
                    this.addAction(blockPos.offset(direction).offset(direction).offset(direction), 0, direction, false);//place rail
                    this.addAction(blockPos.offset(direction).offset(direction), 0, direction, false);//place rail
                    this.addAction(blockPos.offset(direction).offset(direction).offset(yCounterClockwise), 0, yCounterClockwise, true);//break rail
                    this.addAction(blockPos.offset(direction).offset(direction).offset(direction), 0, direction, true);//break rail
                    this.addAction(blockPos.offset(direction).offset(yCounterClockwise), 3, direction, false); //place piston, facing east
                    this.addAction(blockPos.offset(direction).offset(direction).offset(yClockwise), 3, direction, false); //place piston, facing east
                    this.addAction(blockPos.offset(direction).offset(yCounterClockwise).offset(yCounterClockwise), 4, direction, false); //place powerableBlock
                    this.addAction(blockPos.offset(direction).offset(direction).offset(yClockwise).offset(yClockwise), 4, direction, false); //place powerableBlock
                    this.addAction(blockPos.offset(direction).offset(direction).offset(yCounterClockwise).offset(yCounterClockwise), 2, direction.getOpposite(), false); //place repeater, facing east
                    this.addAction(blockPos.offset(direction).offset(yClockwise).offset(yClockwise), 2, direction.getOpposite(), false); //place repeater, facing east
                    this.addAction(blockPos.offset(direction).offset(yCounterClockwise).up(), 5, DOWN, false); //place carpet
                    this.addAction(blockPos.offset(direction).offset(direction).offset(yClockwise).up(), 5, DOWN, false);; //place carpet
                    this.addAction(blockPos.offset(direction).offset(yCounterClockwise).offset(yCounterClockwise).up(), 5, DOWN, false); //place carpet
                    this.addAction(blockPos.offset(direction).offset(direction).offset(yClockwise).offset(yClockwise).up(), 5, DOWN, false); //place carpet
                    }//new
            if (direction .equals( WEST) || direction .equals( NORTH)){
                    this.addAction(blockPos.offset(direction).offset(yCounterClockwise), 1, DOWN, false); //place torch
                    this.addAction(blockPos.offset(direction).offset(yClockwise), 0, yClockwise, false);//place rail
                    this.addAction(blockPos.offset(direction).offset(direction), 0, direction, false);//place rail
                    this.addAction(blockPos.offset(direction), 0, direction, false);//place rail
                    this.addAction(blockPos.offset(direction).offset(yClockwise), 0, yClockwise, true);//break rail
                    this.addAction(blockPos.offset(direction).offset(direction), 0, direction, true);//break rail
                    this.addAction(blockPos.offset(direction).offset(yCounterClockwise), 1, DOWN, true); //break torch
                    this.addAction(blockPos.offset(direction).offset(direction).offset(yClockwise), 1, DOWN, false); //place torch
                    this.addAction(blockPos.offset(direction).offset(direction).offset(yCounterClockwise), 0, yCounterClockwise, false);//place rail
                    this.addAction(blockPos.offset(direction).offset(direction).offset(direction), 0, direction, false);//place rail
                    this.addAction(blockPos.offset(direction).offset(direction), 0, direction, false);//place rail
                    this.addAction(blockPos.offset(direction).offset(direction).offset(yCounterClockwise), 0, yCounterClockwise, true);//break rail
                    this.addAction(blockPos.offset(direction).offset(direction).offset(direction), 0, direction, true);//break rail
                    this.addAction(blockPos.offset(direction).offset(direction).offset(yClockwise), 1, DOWN, true); //break torch
                    this.addAction(blockPos.offset(direction).offset(yCounterClockwise), 3, direction, false); //place piston, facing east
                    this.addAction(blockPos.offset(direction).offset(direction).offset(yClockwise), 3, direction, false); //place piston, facing east
                    this.addAction(blockPos.offset(direction).offset(yCounterClockwise).offset(yCounterClockwise), 4, direction, false); //place powerableBlock
                    this.addAction(blockPos.offset(direction).offset(direction).offset(yClockwise).offset(yClockwise), 4, direction, false); //place powerableBlock
                    this.addAction(blockPos.offset(direction).offset(direction).offset(yCounterClockwise).offset(yCounterClockwise), 2, direction.getOpposite(), false); //place repeater, facing east
                    this.addAction(blockPos.offset(direction).offset(yClockwise).offset(yClockwise), 2, direction.getOpposite(), false); //place repeater, facing east
                    this.addAction(blockPos.offset(direction).offset(yCounterClockwise).offset(yCounterClockwise).up(), 5, DOWN, false); //place carpet
                    this.addAction(blockPos.offset(direction).offset(direction).offset(yClockwise).offset(yClockwise).up(), 5, DOWN, false);; //place carpet
                    this.addAction(blockPos.offset(direction).offset(yCounterClockwise).up(), 5, DOWN, false); //place carpet
                    this.addAction(blockPos.offset(direction).offset(direction).offset(yClockwise).up(), 5, DOWN, false); //place carpet;//new
            }
            this.blockSize = blockPos.offset(direction).offset(direction);
    }
    fun getStraightV2(direction){
            this.mapping = Mapping_Straight_v2;
            blockPos = new PosWithFun(0,0,0);
            yClockwise = direction.rotateYClockwise(); //right
            yCounterClockwise = direction.rotateYCounterclockwise(); //left
            this.addAction(blockPos.offset(yClockwise, 2).offset(direction), 4, direction, false); //4 powerableblock
            this.addAction(blockPos.offset(yCounterClockwise, 2).offset(direction), 4, direction, false);
            this.addAction(blockPos.offset(yClockwise).offset(direction), 3, direction, false); //piston
            this.addAction(blockPos.offset(yClockwise).offset(direction).up(), 0, direction, false); //rail
            this.addAction(blockPos.offset(direction, 2), 0, direction, false); //rail temporary
            if (direction.equals(NORTH) || direction.equals(WEST)){
                //we need torch
                this.addAction(blockPos.offset(direction, -1).offset(yClockwise),  1,DOWN, true); //torch breaking
                this.addAction(blockPos.offset(direction).offset(yCounterClockwise),  1,UP, false); //torch
            }
            this.addAction(blockPos.offset(direction), 0, direction, false); //rail will be curved
            this.addAction(blockPos.offset(direction, 0).offset(yClockwise), 8, DOWN, true); //Now we can remove temporary powered rail
            this.addAction(blockPos.offset(yClockwise, 2).offset(direction, 2), 2, direction.getOpposite(), false);
            this.addAction(blockPos.offset(yCounterClockwise, 2).offset(direction, 2), 2, direction.getOpposite(), false); //repeater
            this.addAction(blockPos.offset(direction, 2), 0, DOWN, true); //break rail
            this.addAction(blockPos.offset(direction, 2).offset(yCounterClockwise), 8, yCounterClockwise, false); //place temporary powered rail
            this.addAction(blockPos.offset(direction, 2), 8, yCounterClockwise, false); // place powered rail
            this.addAction(blockPos.offset(yClockwise).offset(direction).up(), 0, DOWN, true); //break rail on piston
            //half
            this.addAction(blockPos.offset(yClockwise, 2).offset(direction,3), 4, direction, false); //4 powerableblock
            this.addAction(blockPos.offset(yCounterClockwise, 2).offset(direction,3), 4, direction, false);
            this.addAction(blockPos.offset(yCounterClockwise).offset(direction, 3), 3, direction, false); //piston
            this.addAction(blockPos.offset(yCounterClockwise).offset(direction, 3).up(), 0, yCounterClockwise, false); //rail
            this.addAction(blockPos.offset(direction, 4), 0, direction, false); //rail temporary
            if (direction.equals(NORTH) || direction.equals(WEST)){
                //we need torch
                this.addAction(blockPos.offset(direction).offset(yCounterClockwise),  1,DOWN, true); //torch breaking
                this.addAction(blockPos.offset(direction, 3).offset(yClockwise),  1,UP, false); //torch placing
            }
            this.addAction(blockPos.offset(direction, 3), 0, direction, false); //rail will be curved
            this.addAction(blockPos.offset(direction, 2).offset(yCounterClockwise), 8, DOWN, true); //Now we can remove temporary powered rail
            this.addAction(blockPos.offset(yClockwise, 2).offset(direction, 4), 2, direction.getOpposite(), false);
            this.addAction(blockPos.offset(yCounterClockwise, 2).offset(direction, 4), 2, direction.getOpposite(), false); //repeater
            this.addAction(blockPos.offset(direction, 4).offset(yClockwise), 8, yCounterClockwise, false); //place temporary powered rail
            this.addAction(blockPos.offset(direction, 4), 0, DOWN, true); //rail temporary remove
            this.addAction(blockPos.offset(direction, 4), 8, yClockwise, false); //powered rail
            this.addAction(blockPos.offset(yCounterClockwise).offset(direction, 3).up(), 0, DOWN, true); //rail
            this.blockSize = blockPos.offset(direction, 4);
    }
}
class TaskIterator {
    //Single-use task container
    var currentTask = null;
    var ListOfTask;
    var blockPos;
    var pointer;
    var length;
    var blockSize;
    var cycle = 0;
    var mapping = null;
    //tasks : [PosWithFun(), shouldBreak, item, facing],....
    TaskIterator(tasks, originPos){
        this.ListOfTask = tasks;
        this.blockPos = new PosWithFun(originPos);
        this.length = len(tasks);
        this.pointer = 0;
    }
    TaskIterator(){
        this.ListOfTask = [];
        this.length = 0;
    }
    TaskIterator(originPos){
        this.blockPos = new PosWithFun(originPos);
        this.ListOfTask = [];
        this.length = 0;
    }
    fun isNear(other, allowDistance){
        if (this.blockPos == null || other.blockPos == null){
            return true;
        }
        return this.blockPos.distanceTo(other.blockPos) < allowDistance;
    }
    fun pollSafely(){
        //get Any task that can be executed
        i = 0;
        foreach (tasks : this.ListOfTask){
            pendingTask = tasks.isDone();
            if (pendingTask != null && pendingTask.isAvailable()){
                this.currentTask = pendingTask;
                this.ListOfTask.remove(i);
                this.length--;
                return this.currentTask;
            }
            i++;
        }
        return null;
    }
    fun execute(){
        awaitingTask = this.pollSafely();
        if (awaitingTask != null)
            awaitingTask.finish();

    }
    fun addAction(position, itemstring, direction, shouldBreak){
        if(this.mapping != null){
            if(this.mapping.get(itemstring) != null){
                itemstring = this.mapping.get(itemstring);
            }
        }
        this.length ++;
        this.ListOfTask.append(new Task(position, shouldBreak, itemstring, direction));
    }
    fun addAction(action){
        this.length ++;
        this.ListOfTask.append(action);
    }
    fun attachMapping(mapping){
        this.mapping = mapping;
    }
    fun len(){
        return this.length;
    }
}
class SequencedTaskIterator {
    //Single-use task container
    var currentTask = null;
    var ListOfTask;
    var blockPos;
    var pointer;
    var length = 0;
    var blockSize;
    var cycle = 0;
    var mapping = null;
    //tasks : [PosWithFun(), shouldBreak, item, facing],....
    SequencedTaskIterator(tasks, originPos){
        this.ListOfTask = tasks;
        this.blockPos = new PosWithFun(originPos);
        this.length = len(tasks);
        this.pointer = 0;
    }
    SequencedTaskIterator(){
        this.ListOfTask = [];
        this.length = 0;
    }
    SequencedTaskIterator(originPos){
        this.blockPos = new PosWithFun(originPos);
        this.ListOfTask = [];
        this.length = 0;
    }
    fun isNear(other, allowDistance){
        if (this.blockPos == null || other.blockPos == null){
            return true;
        }
        return this.blockPos.distanceTo(other.blockPos) < allowDistance;
    }
    fun pollSafely(){
        //get Any task that can be executed
        if(this.length <= 0){
            return null;
        }
        foreach (tasks : this.ListOfTask){
            if (tasks.isAvailable() && !tasks.isExecuted){
                return tasks;
            }
        }

        return null;
    }

    fun execute(){
        awaitingTask = this.pollSafely();
        if (awaitingTask != null){
            //messageHolder.sendDebugMessage('execute ' + awaitingTask.formatted());
            awaitingTask.finish();
            //messageHolder.sendDebugMessage('executed ' + awaitingTask.formatted()+'\n');
        }
    }
    fun addAction(position, itemstring, direction, shouldBreak){
        if(this.mapping != null){
            if(this.mapping.get(itemstring) != null){
                itemstring = this.mapping.get(itemstring);
            }
        }
        this.length ++;
        this.ListOfTask.append(new Task(position, shouldBreak, itemstring, direction));
    }
    fun addAction(action){
        this.length ++;
        this.ListOfTask.append(action);
    }
    fun attachMapping(mapping){
        this.mapping = mapping;
    }
    fun len(){
        return this.length;
    }
}





//Initialize Tasks

taskHolder = Set.of();

fillTask = fun ( x, y, z, ex, ey, ez, itemName) {
    taskIterator = new TaskIterator();
    foreach (position : world.getArea(new Pos(x,y,z), new Pos(ex,ey,ez))){
        taskIterator.addAction(position, itemName, null, false);
    }
    taskHolder.add(taskIterator);
    messageHolder.sendDebugMessage('Added task length of '+taskIterator.len());
};
fillDirectionTask = fun ( x, y, z, ex, ey, ez, itemName, direction) {
    taskIterator = new TaskIterator();
    direction = new Direction(direction);
    if (!direction.isValid()){
        return null;
    }
    foreach (position : world.getArea(new Pos(x,y,z), new Pos(ex,ey,ez))){
        taskIterator.addAction(position, itemName, direction, false);
    }
    taskHolder.add(taskIterator);
    messageHolder.sendDebugMessage('Added task length of '+taskIterator.len());
};
pauseTask = fun (){
    pause = !pause;
    messageHolder.sendMessageUnchecked(pause);
};
intervalChangeTask = fun(newInterval){
    sleepInterval = newInterval;
    messageHolder.sendMessageUnchecked('New interval : '+ newInteval + 'ms');
};
blockIntervalChangeTask = fun (newInterval){
    if(newInterval > 0){
        taskInterval = newInterval;
        messageHolder.sendMessageUnchecked('New interval between blocks: '+ newInteval + 'ms');
    }
};
serverPingChangeTask = fun (newInterval){
    if(newInterval > 0){
        serverPing = newInterval;
        messageHolder.sendMessageUnchecked('Server Ping Expected: '+ newInteval + 'ms');
    }
};
trustClientTask = fun (){
    trustClient = !trustClient;
    messageHolder.sendMessageUnchecked('Desync Trust : '+ trustClient );
};
toggleMessageTask = fun (){
    hideMessage = !hideMessage;
    messageHolder.sendMessageUnchecked('Hide message : '+ hideMessage );
};
toggleProtocolTask = fun (newVal){
    accurateBlockPlacement = newVal;
    messageHolder.sendMessageUnchecked('AccurateBlockPlacement : '+ accurateBlockPlacement );
};
demiBoltTask = fun(px, py, pz, direction){
    direction = new Direction(direction);
    if(direction.isValid()){
        t = new CyclicTaskGenerator(new PosWithFun(px, py, pz));
        t.getStraightV2(direction);
        taskHolder.add(t);
    }
    else {
        messageHolder.sendMessageUnchecked("Direction name was not valid");
    }
};
standardBoltTask = fun(px, py, pz, direction){
    direction = new Direction(direction);
    if(direction.isValid()){
        t = new CyclicTaskGenerator(new PosWithFun(px, py, pz));
        t.getStraightV1(direction);
        taskHolder.add(t);
    }
    else {
        messageHolder.sendMessageUnchecked("Direction name was not valid");
    }
};
diagonalBoltTask = fun(px, py, pz, direction){
    direction = new Direction(direction);
    if(direction.isValid()){
        t = new CyclicTaskGenerator(new PosWithFun(px, py, pz));
        t.getDiagonal(direction);
        taskHolder.add(t);
    }
    else {
        messageHolder.sendMessageUnchecked("Direction name was not valid");
    }
};
reachDistanceTask = fun (newVal){
    if(newVal > 0){
        playerReach = newVal;
        messageHolder.sendMessageUnchecked('New player reach distance : '+ newVal );
    }
};

breakingTask = fun (px, py, pz, headless){
    recordPiston = PistonUtils.calculateBreakingPiston(world, new PosWithFun(px, py, pz));
    if (recordPiston == null){
        messageHolder.sendMessageUnchecked("Can't break block with piston, no method found");
    }
    else {
        taskIterator = chainedPistonTaskRecord(recordPiston, headless);
        taskHolder.add(taskIterator);
    }
};
headlessTask = fun (px, py, pz, direction, headless){
    direction = new Direction(direction);
    if(direction.isValid()){
        recordPiston = PistonUtils.calculateBreakingPiston(world, new PosWithFun(px, py, pz), direction);
        if (recordPiston == null){
            messageHolder.sendMessageUnchecked("Can't break block with piston, no method found");
        }
        else {
            taskIterator = chainedPistonTaskRecord(recordPiston, headless);
            taskHolder.add(taskIterator);
        }
    }
    else {
        messageHolder.sendMessageUnchecked("Direction name was not valid");
    }
};
//Register commands.
new NestedCommand([['efill'],['x', 'Integer'],['y', 'Integer'],['z', 'Integer'],['ex', 'Integer'],['ey', 'Integer'],['ez', 'Integer'],['itemName', 'Word']], fillTask).process();
new NestedCommand([['efill'],['x', 'Integer'],['y', 'Integer'],['z', 'Integer'],['ex', 'Integer'],['ey', 'Integer'],['ez', 'Integer'],['itemName', 'Word'], ['direction', 'Word']], fillDirectionTask).process();
new NestedCommand([['eCommand'],['pause']], pauseTask).process();
new NestedCommand([['eCommand'],['toggleMessage']], toggleMessageTask).process();
new NestedCommand([['eCommand'],['AccurateBlockPlacement'], ['bool', 'Boolean']], toggleProtocolTask).process();
new NestedCommand([['eCommand'],['toggleTrustClient']], trustClientTask).process();
new NestedCommand([['eCommand'], ['setInterval'], ['milliseconds', 'Integer']], intervalChangeTask).process();
new NestedCommand([['eCommand'], ['setBlockPlacmentInterval'], ['milliseconds', 'Integer']], blockIntervalChangeTask).process();
new NestedCommand([['eCommand'], ['expectedServerPing'], ['milliseconds', 'Integer']], serverPingChangeTask).process();
new NestedCommand([['eDemiBolt'], ['x', 'Integer'],['y', 'Integer'],['z', 'Integer'], ['direction', 'Word', ['north', 'west', 'east', 'south']]], demiBoltTask).process();
new NestedCommand([['eStandardBolt'], ['x', 'Integer'],['y', 'Integer'],['z', 'Integer'], ['direction', 'Word', ['north', 'west', 'east', 'south']]], standardBoltTask).process();
new NestedCommand([['eDiagonalBolt'], ['x', 'Integer'],['y', 'Integer'],['z', 'Integer'], ['direction', 'Word', ['north', 'west', 'east', 'south']]], diagonalBoltTask).process();
new NestedCommand([['eCommand'], ['setReachDistance'], ['reachDistance', 'Double']], reachDistanceTask).process();
new NestedCommand([['eBedrockBreaking'],  ['x', 'Integer'],['y', 'Integer'],['z', 'Integer'], ['headless', 'Boolean']], breakingTask).process();
new NestedCommand([['eBedrockBreaking'],  ['x', 'Integer'],['y', 'Integer'],['z', 'Integer'], ['direction', 'Word', ['north', 'west', 'east', 'south']], ['headless', 'Boolean']], headlessTask).process();
// Script
//t = new Task(new PosWithFun(249,111,206), 'repeater', 'west');
//t.finish();

//t = new CyclicTaskGenerator(new PosWithFun(player.getLookingAtBlock()).up());
//dir = new Direction('east').rotateYClockwise();
//messageHolder.sendMessage(dir.vector);
//t.getDiagonal(new Direction('east'));
//while (true){
//    t.execute();
//}

//placeWallTorch(new PosWithFun(245,113,243), 'redstone_torch', new Direction('east'));

//How to make waiting task:

//task = pistonExtendRemovalTask(blockPos, facing);
//task = pistonExtendRemovalTask(new PosWithFun(242,112,220), new Direction("up"));

//messageHolder.sendMessage(task.isAvailable());
//taskIterator = new TaskIterator();
//task = new WaitingTask(new PosWithFun(242,112,220), 'shroomlight', null, fun (){return world.isAir(new Pos(242,112,217));});
//taskIterator.addAction(task);
//chainedPistonTaskFull(blockPos, facing1, facing2, torchPos,torchPos2, torchFacing,torchFacing2, headless) //its better to have multiple torch pos for headless
//taskIterator = chainedPistonTaskFull(new PosWithFun(242,112,220),UP, SOUTH, new PosWithFun(241,112,220), new PosWithFun(241,112,220), UP, UP, false);
//taskHolder.add(taskIterator);
i = 0;
//torch, pis
//recordPiston = PistonUtils.calculateBreakingPiston(world, new PosWithFun(player.getLookingAtBlock().getPos()));
//if (recordPiston == null){
//    throwRuntimeError('task was null');
//}
//messageHolder.sendMessage(recordPiston.formatted());
//taskIterator = chainedPistonTaskRecord(recordPiston, true);
//taskHolder.add(taskIterator);
while (true){
    if (pause){
        sleep(50);
        continue;
    }
    foreach (tasks : taskHolder){
        tasks.execute();
        if (sleepInterval > 0){
            sleep(sleepInterval);
        }
    }
}


//PistonUtils.calculateValidTorchPos(world, new PosWithFun(232,111,219), NORTH);
