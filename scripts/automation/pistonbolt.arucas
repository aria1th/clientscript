import * from Minecraft;
import Java from util.Internal;
import LinearCommand from minecraft.CommandUtils;
import DefaultSuggester from minecraft.CommandUtils;
import * from minecraft.PosUtils;
import * from minecraft.MinecraftUtils;
import * from minecraft.InventoryUtils;


client = MinecraftClient.getClient();
clientJava = Java.valueOf(client);

jWorld = clientJava.world;
player = client.getPlayer();
world = client.getWorld();



playerReach = 4.5;
accurateBlockPlacement = false;
carefulBreakSneak = false;
messageHolder = new MessageHolder();
delayedHolder = new BedrockBreakingTaskSeparator();
leftovers = new LeftOverProcessingTask();
messageHolder.debugFlag = true;
pistonItem = 'piston';
spawnChecker = new SpawnConditionCheck(world);
taskInterval = 15; //10ms interval
serverPing = 150;
trustClient = true;
tickCount = 2;
immediateInterval = 0;
//Hardcode sequences
Mapping_Diagonal =   {0 : 'rail', 1 : 'redstone_torch', 2 : 'repeater', 3 : 'sticky_piston', 4 : 'shroomlight', 5 : 'white_carpet', 6 : 'redstone', 7 : 'sea_lantern'};
Mapping_Straight =   {0 : 'rail', 1 : 'redstone_torch', 2 : 'repeater', 3 : 'piston', 4 : 'shroomlight', 5 : 'white_carpet', 6 : 'redstone', 7 : 'sea_lantern'};
Mapping_Straight_v2 = {0 : 'rail', 1 : 'redstone_torch', 2 : 'repeater', 3 : 'piston', 4 : 'shroomlight', 5 : 'white_carpet', 6 : 'redstone', 7 : 'sea_lantern', 8 : 'powered_rail'};
NORTH = Direction.NORTH;
SOUTH = Direction.SOUTH;
WEST = Direction.WEST;
EAST = Direction.EAST;
UP = Direction.UP;
DOWN = Direction.DOWN;
pause = false;
railPoweringTaskOff = true;
railPowerItem = 'netherrack';
spawnProofItem = 'glass';
spawnProofTaskOn = false;
sleepInterval = 0;
hideMessage = true;
singleUsePosSet = Set.of();

AreaPos1 = null;
AreaPos2 = null;

inventoryAccess = new InventoryUtil(player);
//inventoryAccess.debug = true;
// Functions
fun assertHaste(){
    foreach ( effectname : player.getStatusEffects()){
        if (effectname == 'haste')
            return true;
    }
    return false;
}
fun isInHotbar(itemString){
    return inventoryAccess.isInHotbar(itemString);
}
fun checkCanPlaceAt(position, block){
    jBlock = Java.valueOf(block); //blockState
    jPosition = position.asJavaPos();
    return jBlock.getBlock().canPlaceAt(jBlock, jWorld, jPosition).toArucas();
}
fun swapToItem(itemString){
    return inventoryAccess.swapToItem(itemString);
}
fun checkItem(itemString){
    return inventoryAccess.checkItem(itemString);
}
// Swaps to pickaxe.
fun swapToPickaxe(){
    return inventoryAccess.swapToPickaxe();
}
fun checkPickaxe(){
    return inventoryAccess.checkPickaxe();
}
fun assertItem(itemString){
    return inventoryAccess.assertItem(itemString);
}

fun assertTool(){
    return inventoryAccess.assertTool();
}
fun breakBlock(pos, requireSneak){
    if (Type.of(pos).getName() != 'Pos'){
        pos = pos.asPos();
    }
	if (world.getBlockAt(pos).getHardness() == -1 || world.getBlockAt(pos).isFluid() || world.isAir(pos)) {
	    player.attackBlock(pos,'up');
	    messageHolder.sendDebugMessage("Block "+ pos + world.getBlockAt(pos)+" was not breakable");
	    if (world.getBlockAt(pos).getId() == 'moving_piston'){
	        messageHolder.sendDebugMessage("Block "+ pos + world.getBlockAt(pos)+" was moving piston, waiting 100ms and breaking...");
	        sleep(100);
	        player.attackBlock(pos,'up');
	    }
	    return;
	}
	if (world.getBlockAt(pos).getHardness() == 0 && !world.getBlockAt(pos).isReplaceable()) {
	    player.attackBlock(pos,'up');
	    return;
	}
	if (!world.getBlockAt(pos).isReplaceable() ) {
	    assertTool();
        if (isBlockInstantBreakable(pos)){
            player.attackBlock(pos,'up');
            return;
        }
	    while(!world.getBlockAt(pos).isReplaceable()) {
	    	sleep(50);
	    	if (requireSneak) {player.setSneaking(true);}
	    	player.updateBreakingBlock(pos);
	    	if(world.getBlockAt(pos).isReplaceable()){break;}
	    }
	}
}
fun isBlockInstantBreakable(pos){
    if (assertHaste()){
        return true;
    }
    //assume pickaxe
    b = world.getBlockAt(pos);
    //hardness * 30 <
    if (b.getId() == 'piston' || b.getId() == 'sticky_piston'){
         property = b.getBlockProperties();
         if (property.get('extended') && world.getBlockAt(pos.offset(property.get('facing'))).getId() == 'moving_piston'){
         }
    }
    messageHolder.sendDebugMessage(player.getBlockBreakingSpeed(b));
    messageHolder.sendDebugMessage(b.getHardness() * 30);
    return player.getBlockBreakingSpeed(b) >=  b.getHardness() * 30;
}

//Simple carpet protocol
fun applyCarpetProtocol(x,y,z,direction){
    if (direction == Direction.NONE) {return [x,y,z];}
	dirId = getDirectionId(direction);
	return [x+2*dirId + 2, y, z];
}
fun getDirectionId(dir) {
    if (dir.isValid()){
        return dir.ordinal();
    }
    return 0;
}
fun placeTorch(blockPos, itemString){
	assertItem(itemString);
	if (assertItem(itemString) || trustClient){
	    x = blockPos.getX();
	    y = blockPos.getY();
	    z = blockPos.getZ();
	    player.interactBlock(x,y,z,"up",x,y-1,z,false);
	    return true;
	}
	return false;
}
fun placeWallTorch(blockPos, itemString, torchFacing){
    clickPos = blockPos.offset(torchFacing.getOpposite());
    if (!world.getBlockAt(clickPos.getX(),clickPos.getY(),clickPos.getZ()).sideCoversSmallSquare(torchFacing.getName())){
        messageHolder.sendMessage("position "+ clickPos.formatted() + ' does not handle wall torch.');
        return false;
    }
	assertItem(itemString);
	if (assertItem(itemString) || trustClient){
	    clickVec = clickPos.getSidePos(torchFacing);
	    player.interactBlock( clickVec.getX(), clickVec.getY(), clickVec.getZ(),torchFacing.getName(),clickPos.getX(),clickPos.getY(),clickPos.getZ(),false);
	    messageHolder.sendDebugMessage(clickPos.formatted() + ' '+ clickVec.formatted());
	    return true;
	}
	return false;
}
fun requiredOffsetCheck(blockPos, itemString, torchFacing){
    //WallMountedBlock, we need library maybe?
    if (torchFacing == null){
        torchFacing = Direction.DOWN;
    }
    if (itemString.contains('torch') && torchFacing.axis != Axis.Y){
        clickPos = blockPos.offset(torchFacing.getOpposite());
        if (!world.getBlockAt(clickPos.getX(),clickPos.getY(),clickPos.getZ()).sideCoversSmallSquare(torchFacing.getName())){
            return false;
        }
    }
    else {
        return checkCanPlaceAt(blockPos, ItemStack.of(Material.of(itemString)).asBlock());
    }
    return true;
}
fun getLookRefYawPitchDirection(itemString,direction){
    if (itemString.contains('torch')){
        return null;
    }
    fy = 0;
    fp = 0;
	if (direction.isValid()) {
	    if (itemString.contains("piston") || itemString.contains("repeater")){
	    	direction = direction.getOpposite(); //well actually, we might need to have testing function
	    }
	    fy = player.getYaw();
	    fp = player.getPitch();
	    if (direction  == Direction.UP) {
	    	fy = 0;
	    	fp = -90;
	    }
	    else if (direction  == Direction.DOWN) {
	    	fy = 0;
	    	fp = 90;
	    }
	    else if (direction  == Direction.EAST) {
	    	fy = -90;
	    	fp = 0;
	    }
	    else if (direction  == Direction.WEST) {
	    	fy = 90;
	    	fp = 0;
	    }
	    else if (direction  == Direction.NORTH) {
	    	fy = 180;
	    	fp = 0;
	    }
	    else if (direction  == Direction.SOUTH) {
	    	fy = 0;
	    	fp = 0;
	    }
	    return [fy, fp, direction];
	}
	else {
	    return null;
	}
}
fun placeDirectionBlock(blockPos,itemString, direction, immediate){
    if(itemString.contains('torch')){
        if (direction.axis == Axis.Y)
            return placeTorch(blockPos, itemString);
        else {
            return placeWallTorch(new PosWithFun(blockPos), itemString, direction);
        }
    }
    fy = 0;
    fp = 0;
	if (direction.isValid()) {
	    if (!accurateBlockPlacement && (itemString.contains("piston") || itemString.contains("repeater"))){
	    	direction = direction.getOpposite(); //well actually, we might need to have testing function
	    }
	    fy = player.getYaw();
	    fp = player.getPitch();
	    if (direction  == Direction.UP) {
	    	fy = 0;
	    	fp = -90;
	    }
	    else if (direction  == Direction.DOWN) {
	    	fy = 0;
	    	fp = 90;
	    }
	    else if (direction  == Direction.EAST) {
	    	fy = -90;
	    	fp = 0;
	    }
	    else if (direction  == Direction.WEST) {
	    	fy = 90;
	    	fp = 0;
	    }
	    else if (direction  == Direction.NORTH) {
	    	fy = 180;
	    	fp = 0;
	    }
	    else if (direction  == Direction.SOUTH) {
	    	fy = 0;
	    	fp = 0;
	    }
	}
	assertItem(itemString);
	if (assertItem(itemString) || trustClient){
	    x = blockPos.getX();
	    y = blockPos.getY();
	    z = blockPos.getZ();
	    py = y;
	    if ((direction != null && !accurateBlockPlacement) || itemString.contains("rail")) {
	    	player.fakeLook(fy,fp,direction.getName(),6);
	    	if (!immediate){
	    	    sleep(50);
	    	}
	    	player.interactBlock(x,py,z,direction.getName(),x,y,z,false);
	    	if (itemString.contains("rail")){
	    	    if (!immediate){
	    	        sleep(50);
	    	    }
	    	}
	    } else if (direction != null && accurateBlockPlacement){
	    	carpetVec = applyCarpetProtocol(x,y,z,direction);
	    	hx = carpetVec.get(0);
	    	hy = carpetVec.get(1);
	    	hz = carpetVec.get(2);
	    	player.interactBlock(hx,hy,hz,direction.getName(),x,py,z,true);
	    }
	    else {
            player.interactBlock(x,y,z,"north",x,y,z,false);
	    }
	    return true;
	}
	else {
	    return false;
	}
}
fun matchProperty(blockPos,blockId, propertyMap){
    //matches blockState with property
    cblock = world.getBlockAt(blockPos.asPos());
    if (cblock.getId() != blockId){
        return false;
    }
    mapping = cblock.getBlockProperties();
    foreach ( properties : propertyMap.getKeys()){
        if (propertyMap.get(properties) != mapping.get(properties)){
            return false;
        }
    }
    return true;
}
//Functions that generates Objects because there is no class A extends B in arucas
//Sensei you got more work!


//generated observingTask that executes with observed Position block has desired block, and properties.

fun observingTask(blockPos,shouldBreak, itemString, facing, observePos, blockId, propertyMap){
    predicate = fun (){return matchProperty(observePos, blockId, propertyMap);};
    if (shouldBreak){
        return new WaitingTask(blockPos, predicate);
    }
    else {
        return new WaitingTask(blockPos, itemString, facing, predicate);
    }
    return null;
}
//Piston removal when it extends.
fun pistonExtendRemovalTask(blockPos, facing){
    shouldBreak = true;
    itemString = pistonItem;
    observePos = blockPos;
    blockId = pistonItem;
    propertyMap = {'extended' : true};
    return observingTask(blockPos,true, itemString, facing, observePos, blockId, propertyMap);
}
fun pistonExtendRemovalTask(blockPos, facing, observePos){
    shouldBreak = true;
    propertyMap = {'extended' : true};
    return observingTask(blockPos,true, pistonItem, facing, observePos, pistonItem, propertyMap);
}
fun pistonHeadFindingPredicate(blockPos, facing){
    return fun(){return world.getBlockAt(blockPos.offset(facing).asPos()).getId() == 'piston_head';};
}
fun pistonRetractFindingPredicate(blockPos, facing){
    return fun(){return world.getBlockAt(blockPos.offset(facing).asPos()).getId() == 'moving_piston';};
}
//Piston placement when A extends then B executes
// We place piston in pos A, with torch at pos B, then wait until it 'extends'. if moving piston is found, remove torch first then piston, and replace (torch - optional) then piston with new direction. pt-tp-tp
//
fun chainedPistonTaskRecord(record, headless){
    facing1 = record.pistonFacing;
    facing2 = record.finalFacing;
    bedrockPos = record.pistonPos.offset(facing2);
    torchFacing = record.torchFacing;
    torchPos = record.torchPos;
    pistonPos = record.pistonPos;
    iter = new SequencedTaskIterator();
    tempTask = null;
    if (!accurateBlockPlacement){
        fy, fp, requiredDirection = getLookRefYawPitchDirection(pistonItem,facing1);
        tempTask = new FakeLookWaitingTask(fy, fp, requiredDirection, fun () {return true;});
        iter.addAction(tempTask);
    }
    task1 = new WaitingTask(pistonPos, pistonItem, facing1, fun (){if (tempTask == null){return true;} else {if(tempTask.isExecuted){sleep(10); return true;} else {return false;} }}); //place piston
    iter.addAction(task1);
    tempTask2 = null;
    if (!accurateBlockPlacement){
        fy, fp, requiredDirection = getLookRefYawPitchDirection(pistonItem,facing2);
        tempTask2 = new FakeLookWaitingTask(fy, fp, requiredDirection, fun () {return true;});
        iter.addAction(tempTask2);
    }
    task2 = new WaitingTask(torchPos, 'redstone_torch', torchFacing, fun (){if (tempTask2 == null){return task1.isExecuted;} else {if(task1.isExecuted && tempTask2.isExecuted){sleep(10); return true;} else {return false;} }});
    iter.addAction(task2);
    //optional slime block placement.
    task3 = new WaitingTask(torchPos, pistonHeadFindingPredicate(pistonPos, facing1)); //break torch
    task3.setImmediate(true);
    iter.addAction(task3);
    torchRemovePredicate = fun(){return task3.isExecuted;};
    task6 = new WaitingTask(torchPos, 'redstone_torch', torchFacing, torchRemovePredicate);//we use secondary position that prevents desync
    task4FinishPredicate = fun(){return task6.isExecuted;};
    task6.setImmediate(true);
    task4 = new WaitingTask(pistonPos, fun(){return task6.isExecuted;}); //remove piston
    task4FinishPredicate = fun(){return task4.isExecuted;}; //check if done
    task4.setImmediate(true);
    task5 = new WaitingTask(pistonPos, pistonItem, facing2, task4FinishPredicate); //place piston
    task5.setImmediate(true);
    iter.addAction(task6);
    iter.addAction(task4);
    iter.addAction(task5);
    if (!headless){
        task7 = new WaitingTask(torchPos, fun (){if(task5.isExecuted){sleep(20);return true;};return false;});
        iter.addAction(task7);
        task8 = new WaitingTask(pistonPos, fun () {if (world.isAir(bedrockPos.asPos())){sleep(10); leftovers.addPos(pistonPos); return true;} else if (task7.isExecuted){leftovers.addPos(pistonPos); sleep(150); return true;}; return false;}); //remove piston
        iter.addAction(task8);
    }
    iter.prettyPos = pistonPos;
    return iter;
}
fun chainedPistonTaskRecord2(record, headless){
    facing1 = record.pistonFacing;
    facing2 = record.finalFacing;
    bedrockPos = record.pistonPos.offset(facing2);
    torchFacing = record.torchFacing;
    torchPos = record.torchPos;
    pistonPos = record.pistonPos;
    iter = new SequencedTaskIterator();
    task1 = new Task(pistonPos, pistonItem, facing1); //place piston
    iter.addAction(task1);
    if (!accurateBlockPlacement){
        fy, fp, requiredDirection = getLookRefYawPitchDirection(pistonItem,facing2);
        iter.addAction(new FakeLookWaitingTask(fy, fp, requiredDirection, fun () {return task1.isExecuted;}));
    }
    task2 = new Task(torchPos, 'redstone_torch', torchFacing); //place torch
    iter.addAction(task2);
    //optional slime block placement.
    task3 = new WaitingTask(torchPos, pistonHeadFindingPredicate(pistonPos, facing1)); //break torch
    task3.setImmediate(true);
    iter.addAction(task3);
    torchRemovePredicate = fun(){return task3.isExecuted;};
    if (headless){
        task6 = new WaitingTask(torchPos, 'redstone_torch', torchFacing, torchRemovePredicate);//we use secondary position that prevents desync
        task4FinishPredicate = fun(){return task6.isExecuted;};
        task6.setImmediate(true);
        task4 = new WaitingTask(pistonPos, fun(){return task6.isExecuted;}); //remove piston
        task4FinishPredicate = fun(){return task4.isExecuted;}; //check if done
        task4.setImmediate(true);
        task5 = new WaitingTask(pistonPos, pistonItem, facing2, task4FinishPredicate); //place piston
        task5.setImmediate(true);
        iter.addAction(task6);
        iter.addAction(task4);
        iter.addAction(task5);
    }
    else {
        task4 = new WaitingTask(pistonPos, torchRemovePredicate); //remove piston
        task4FinishPredicate = fun(){return task4.isExecuted;}; //check if done
        task4.setImmediate(true);
        task5 = new WaitingTask(pistonPos, pistonItem, facing2, task4FinishPredicate); //place piston
        task5.setImmediate(true);
        iter.addAction(task4);
        iter.addAction(task5);
        task6 = new WaitingTask(pistonPos, fun () {if (world.isAir(bedrockPos.asPos())){sleep(100); return true;} else {return false;}}); //remove piston
        iter.addAction(task6);
        task7 = new WaitingTask(pistonPos, fun () {return task6.isExecuted && world.isAir(pistonPos.asPos());});
        iter.addAction(task7);
    }
    iter.prettyPos = pistonPos;
    return iter;
}
fun chainedPistonTaskBreak(blockPos, facing1, facing2, torchPos, torchFacing){ //same pos, breaks block
    iter = new SequencedTaskIterator();
    task1 = new Task(blockPos, pistonItem, facing1); //place piston
    task2 = new Task(torchPos, 'redstone_torch', torchFacing); //place torch
    //optional slime block placement.
    task3 = new WaitingTask(torchPos, pistonHeadFindingPredicate(blockPos, facing1)); //break torch
    task3.setImmediate(true);
    torchRemovePredicate = fun(){return task3.isExecuted;};
    task4 = null;
    task4 = new WaitingTask(blockPos, torchRemovePredicate); //remove piston
    task4FinishPredicate = fun(){return task4.isExecuted;}; //check if done
    task4.setImmediate(true);
    task5 = new WaitingTask(blockPos, pistonItem, facing2, task4FinishPredicate); //place piston
    task5.setImmediate(true);
    iter.addAction(task1);
    iter.addAction(task2);
    iter.addAction(task3);
    iter.addAction(task4);
    iter.addAction(task5);
    return iter;
}
fun chainedPistonTaskSelect(blockPos, facing1, facing2, torchPos, torchFacing, headless){ //same pos but with headless selection
    iter = new SequencedTaskIterator();
    task1 = new Task(blockPos, pistonItem, facing1); //place piston
    task2 = new Task(torchPos, 'redstone_torch', torchFacing); //place torch
    //optional slime block placement.
    task3 = new WaitingTask(torchPos, pistonHeadFindingPredicate(blockPos, facing1)); //break torch
    task3.setImmediate(true);
    torchRemovePredicate = fun(){return task3.isExecuted;};
    task4 = null;
    if (headless){
        task6 = new WaitingTask(torchPos, 'redstone_torch', torchFacing, torchRemovePredicate);//we use secondary position that prevents desync
        task4FinishPredicate = fun(){return task6.isExecuted;};
        task6.setImmediate(true);
        task4 = new WaitingTask(blockPos, fun(){return task6.isExecuted;}); //remove piston
        task4FinishPredicate = fun(){return task4.isExecuted;}; //check if done
        task4.setImmediate(true);
        task5 = new WaitingTask(blockPos, pistonItem, facing2, task4FinishPredicate); //place piston
        task5.setImmediate(true);
        iter.addAction(task1);
        iter.addAction(task2);
        iter.addAction(task3);
        iter.addAction(task4);
        iter.addAction(task6);
        iter.addAction(task5);
    }
    else {
        task4 = new WaitingTask(blockPos, torchRemovePredicate); //remove piston
        task4FinishPredicate = fun(){return task4.isExecuted;}; //check if done
        task4.setImmediate(true);
        task5 = new WaitingTask(blockPos, pistonItem, facing2, task4FinishPredicate); //place piston
        task5.setImmediate(true);
        iter.addAction(task1);
        iter.addAction(task2);
        iter.addAction(task3);
        iter.addAction(task4);
        iter.addAction(task5);
    }
    return iter;
}

//classes
class DefaultedMap {
    var map;
    var defaultValue = null;
    DefaultedMap(items){
        this.map = {};
        foreach (item : items){
            this.map.put(item, this.defaultValue);
        }
    }
    DefaultedMap(items, defaultValue){
        this.map = {};
        this.defaultValue = defaultValue;
        foreach (item : items){
            this.map.put(item, this.defaultValue);
        }
    }
    fun addAll(values){
        if (Type.of(values).getName() == 'List'){
            foreach (item : values){
                this.map.put(item, this.defaultValue);
            }
        }
        else {
            this.map.addAll(values);
        }
    }
    fun getValues(){
        return this.map.getValues();
    }
    fun containsKey(key){
        return this.map.conatinsKey();
    }
    fun putAll(other){
        this.map.putAll(other);
    }
    fun addList(other){
        this.map.putAll(new DefaultedMap(other).map);
    }
    fun get(key){
        return this.map.get(key);
    }
    fun isEmpty(){
        return this.map.isEmpty();
    }
    fun clear(){
        this.map.clear();
    }
    fun toString(){
        return this.map.toString();
    }
    fun getKeys(){
        return this.map.getKeys();
    }
    fun putIfAbsent(key, value){
        return this.map.putIfAbsent(key, value);
    }
    fun remove(key){
        if (key == null){
            return null;
        }
        return this.map.remove(key);
    }
    fun put(key, value){
        return this.map.put(key, value);
    }
    fun put(key){
        return this.map.put(key, this.defaultValue);
    }
    fun poll(){
        if (!this.isEmpty())
            return this.map.getKeys().get(0);
    }
}
class MessageHolder{
    //message holding class that prevents spamming same message
    var stringSet;
    var debugFlag;
    var previousMessage ;
    var actionbar = false;
    MessageHolder(){
        this.stringSet = Set.of();
    }
    fun sendMessage(message){
        if(this.previousMessage == message){
            return;
        }
        if (this.actionbar){
            player.messageActionBar(message);
        }
        else {
            player.message(message);
        }
        this.stringSet.add(message);
        this.previousMessage = message;
    }
    fun sendMessageUnique(message){
        if (this.stringSet.contains(message)){
            return;
        }
        if (this.debugFlag && !hideMessage){
            this.sendMessage(message);
        }
        this.stringSet.add(message);
    }
    fun sendMessageUnchecked(message){
        if (this.actionbar){
            player.messageActionBar(message);
        }
        else {
            player.message(message);
        }
        this.stringSet.add(message);
    }
    fun sendDebugMessage(message){
        if (this.debugFlag && !hideMessage){
            this.sendMessage(message);
        }
    }
}
class ClickTask {
    //instantly calculate difference and click
    var blockPos;
    var ignoreDistance = false;
    var wantedStateProperty = {}; //Noteblock : note, repeater - delay, comparator - mode, redstone dust : east(for example)
    ClickTask(blockPos, stateProperty){
        this.blockPos = blockPos;
        this.wantedStateProperty = stateProperty; //Map of properties
    }
    ClickTask(blockPos){
        this.blockPos = blockPos;
        this.wantedStateProperty = {'delay' : 1, 'mode' : 'compare', 'east' : 'side', 'note' : 0}; //Map of properties
    }
    fun repeaterStatus(){
        clientDelay = world.getBlockAt(this.blockPos.asPos()).getBlockProperties().get('delay');
        if(clientDelay == null){
            return 0;
        }
        messageHolder.sendDebugMessage(this.blockPos.formatted() + ' has wrong delay, could be desync?');
        return Math.mod(this.wantedStateProperty.get('delay') - clientDelay, 4);
    }
    fun comparatorStatus(){
        clientMode = world.getBlockAt(this.blockPos.asPos()).getBlockProperties().get('mode');
        if (clientMode == null || clientMode == this.wantedStateProperty.get('mode')){
            return 0;
        }
        messageHolder.sendDebugMessage(this.blockPos.formatted() + ' has wrong mode, could be desync?');
        return 1;
    }
    fun dustStatus(){
        clientConnected = world.getBlockAt(this.blockPos.asPos()).getBlockProperties().get('east');
        if (clientConnected == null || clientConnected == this.wantedStateProperty.get('east')){
            return 0;
        }
        messageHolder.sendDebugMessage(this.blockPos.formatted() + ' has wrong dust shape, could be desync?');
        return 1;
    }
    fun noteBlockStatus(){
        clientNote = world.getBlockAt(this.blockPos.asPos()).getBlockProperties().get('note');
        if(clientNote == null){
            return 0;
        }
        messageHolder.sendDebugMessage(this.blockPos.formatted() + ' has wrong note, could be desync?');
        return Math.mod(this.wantedStateProperty.get('note') - clientNote, 25);
    }
    fun fix(){
        clickTimes = this.repeaterStatus() + this.comparatorStatus() + this.dustStatus() + this.noteBlockStatus();
        for (i = 0; i < clickTimes; i++) {
            player.interactBlock(this.blockPos.asPos(), "up");
            sleep(16);
        }

    }
}
class Task {
    // task that has what to do, break / item with directions
    var pos;
    var shouldBreak;
    var item;
    var block; //item.asBlock()
    var facing = Direction.NONE;
    var itemString;
    var optional = 0;
    var connectedTask = null;
    var isExecuted = false;
    var withBlockState;
    var immediate = false;
    var ignoreDistance = false;
    var predicate = fun (){return true;};
    Task(pos, itemName, direction){
        this.pos = new PosWithFun(pos);
        this.shouldBreak = false;//ItemStack.of(Material.of(itemName)).asBlock();
        this.item = ItemStack.of(Material.of(itemName));
        this.block = this.item.asBlock();
        this.itemString = itemName;
        if (direction != null)
            this.facing = direction;
    }
    Task(pos){
        this.pos = new PosWithFun(pos);
        this.shouldBreak = true;
        this.item = null;
        this.facing = Direction.NONE;
    }
    Task(pos, b, i, f){
        this.pos = new PosWithFun(pos);
        this.shouldBreak = b;
        if (!b){
            if (Type.of(i).getName() == 'String'){
                i = ItemStack.of(Material.of(i));
            }
            this.item = i;
            this.itemString = this.item.getId();
            this.block =  this.item.asBlock();
        }
        if (f != null)
            this.facing = f;
    }
    Task(pos, b, i, f, optional){
        this.pos = new PosWithFun(pos);
        this.shouldBreak = b;
        if (!b){
            this.item = i;
            this.itemString = i.getId();
            this.block = i.asBlock();
        }
        this.facing = f;
        this.optional = optional;
    }
    fun add(otherPos){
        return new Task(this.pos.add(otherPos), this.shouldBreak, this.item, this.facing);
    }
    fun hash(){
        return '' + this.pos + this.shouldBreak + this.itemString + this.facing;
    }
    fun isDone(){
    // null returns for nothing required
        pos = this.pos.asPos();
        clientBlock = world.getBlockAt(pos);
        if (this.shouldBreak && clientBlock.isReplaceable()){
            //break task, finished
            this.isExecuted = true;
            return null;
        }
        else if (this.shouldBreak && !clientBlock.isReplaceable()) {
            if (this.isExecuted && trustClient){
                return null;
            }
            return this;
        }
        else if (!this.shouldBreak && clientBlock.isReplaceable()){
            //place task, but empty
            if (this.isExecuted && trustClient){
                return null;
            }
            return this;
        }
        state = clientBlock;
        if (state.getId() != this.block.getId()){
            //wall torch exceptions
            if (state.getId().contains('wall')){
                this.isExecuted = true;
                return null;
            }
            if (this.connectedTask != null && trustClient && this.connectedTask.isExecuted){
                return null;
            }
            //place task, but break first
            this.connectedTask = new Task(this.pos);
            return this.connectedTask;
        }
        //if (this.facing != null && state.getBlockProperties().get('facing') != this.facing){
        //    return new Task(this.pos);
        //}
        return null;
    }
    fun internalAssertItem(){
        if (this.shouldBreak){
            if (isBlockInstantBreakable(this.pos.asPos())){
                return true;
            }
            return assertTool();
        }
        return assertItem(this.itemString);
    }
    fun checkInventory(){
        if (this.shouldBreak){
            return checkPickaxe();
        }
        return checkItem(this.itemString);
    }
    fun internalCanProcess(){
        if (this.pos.isNear(player, playerReach) || this.ignoreDistance){
         if (trustClient || this.internalAssertItem())
            return true;
        }
        return false;
        //returns if player has item or tool and reach
    }
    fun isAvailable(){
        return (this.ignoreDistance || this.pos.isNear(player, playerReach) ) && this.checkInventory() && (this.shouldBreak || requiredOffsetCheck(this.pos, this.itemString, this.facing)) ;
    }
    fun findReason(){
        if (!this.pos.isNear(player, playerReach)){
            return "Position is not near to player pos " + player.getPos() +" " + this.pos.formatted();
        }
        if (!this.checkInventory()){
            return "Does not have item";
        }
        if (!requiredOffsetCheck(this.pos, this.itemString, this.facing)){
            return "can't place block at pos "+ this.pos;
        }
        return "available";
    }
    fun process(){
    // checks, returns if processed
        if (this.internalCanProcess()){
            if(!this.isImmediate()){
                sleep(taskInterval);
            }
            else {
                sleep(immediateInterval);
            }
            if (!hideMessage)
                messageHolder.sendDebugMessage(this.formatted());
            if (this.shouldBreak){
                assertTool();
                _ = breakBlock(this.pos.asPos(), carefulBreakSneak);
                this.isExecuted = true;
                messageHolder.sendDebugMessage(this.formattedSuccess());
                return true;
            }
            else {
                if (this.itemString == null){
                    throw new Error('itemString was null' + this.pos.formatted());
                }
            }
            result = placeDirectionBlock(this.pos.asPos(),this.itemString,this.facing, this.isImmediate());
            if (result){
                this.isExecuted = true;
                messageHolder.sendDebugMessage(this.formattedSuccess());
                return true;
            }
            else {
                messageHolder.sendMessage(this.formattedError());
            }
        }
        else {
            messageHolder.sendMessage(this.formattedError() + "Reason : not available");
        }
        return false;
    }
    fun execute(){
    //direct excution.
        return this.finish();
    }
    fun executeOrElse(){
        if (this.internalCanProcess()){
            this.process();
        }
        else {
            messageHolder.sendMessage(this.findReason());
        }
    }
    fun finish(){
        while (true){
            if (this.isExecuted){
                return;
            }
            messageHolder.sendMessageUnique(this.formatted());
            pendingTask = this.isDone();
            if (pendingTask != null){
                if (!pendingTask.checkInventory()){
                    messageHolder.sendMessage(pendingTask.formattedError());
                    break;
                }
                result = pendingTask.process();
                if (result){
                    if (trustClient){
                        if (this != pendingTask){
                            if (!pendingTask.checkInventory()){
                            //No inventory item
                                messageHolder.sendMessage(this.formattedError());
                                break;
                            }
                            this.process();
                        }
                        if (this.isDone() == null){
                            break;
                        }
                        else {
                            this.isDone().process();
                            break;
                        }
                    }
                    else {
                        sleep(serverPing);
                    }

                }
            }
            //null
            else {
                break;
            }
        }
    }
    fun isImmediate(){
        return this.immediate;
    }
    fun setImmediate(bool){
        this.immediate = bool;
    }
    fun formattedError(){
        if (this.shouldBreak){
            return 'failed to break block at '+ this.pos.formatted();
        }
        return 'failed to place ' + this.itemString + ' at ' + this.pos.formatted();
    }
    fun formatted(){
        if (this.shouldBreak){
            return 'break block at '+ this.pos.formatted();
        }
        return 'place ' + this.itemString + ' at ' + this.pos.formatted();
    }
    fun formattedSuccess(){
        if (this.shouldBreak){
            return 'broke block at '+ this.pos.formatted()+ ' at' + getMilliTime();
        }
        return 'placed ' + this.itemString + ' at ' + this.pos.formatted()+ ' at' + getMilliTime();
    }
    fun copy(){
        return new Task(this.pos.copy(), this.shouldBreak, this.item, this.facing, this.optional + 1);
    }
}
class FakeLookWaitingTask{
    var fy;
    var fp;
    var pos = null;
    var direction = Direction.NONE;
    var predicate = fun(){return true;};
    var immediate = true;
    var isExecuted = false;
    var ignoreDistance = true;
    FakeLookWaitingTask(fy, fp, direction, predicate){
        this.fy = fy;
        this.fp = fp;
        this.direction = direction;
        this.predicate = predicate;
    }
    fun isDone(){
        if (this.isExecuted){
            return null;
        }
        return this;
    }
    fun internalCanProcess(){
        return this.predicate();
    }
    fun isAvailable(){
        return this.predicate();
    }
    fun process(){
        if (this.internalCanProcess()){
            messageHolder.sendDebugMessage('fake look ' + this.direction.getName());
            player.fakeLook(this.fy, this.fp, this.direction.getName(), 6);
            this.isExecuted = true;
            return true;
        }
        return false;
    }
    fun finish(){
        return this.process();
    }
    fun isImmediate(){
        return this.immediate;
    }
    fun formatted(){
        return 'Fake look '+ this.direction.getName();
    }
}

class WaitingTask {
    // Task with predicate check to execute, such as block observe
    var pos;
    var shouldBreak;
    var item;
    var block; //item.asBlock()
    var facing = Direction.NONE;
    var itemString;
    var optional = 0;
    var connectedTask = null;
    var isExecuted = false;
    var withBlockState;
    var predicate = fun (){return true;};
    var immediate = false;
    var ignoreDistance = false;
    WaitingTask(pos, itemName, direction, predicate){
        this.pos = new PosWithFun(pos);
        this.shouldBreak = false;
        this.item = ItemStack.of(Material.of(itemName));
        this.block = this.item.asBlock();
        this.itemString = itemName;
        this.facing = direction;
        this.predicate = predicate;
    }
    WaitingTask(pos, predicate){
        this.pos = new PosWithFun(pos);
        this.shouldBreak = true;
        this.item = null;
        this.facing = Direction.NONE;
        this.predicate = predicate;
    }
    WaitingTask(pos, b, i, f, predicate){
        this.pos = new PosWithFun(pos);
        this.shouldBreak = b;
        if (Type.of(i).getName() == 'String'){
            i = ItemStack.of(Material.of(i));
        }
        this.item = i;
        this.itemString = i.getId();
        this.block = i.asBlock();
        this.facing = f;
        this.predicate = predicate;
    }
    WaitingTask(pos, b, i, f,predicate, optional){
        this.pos = new PosWithFun(pos);
        this.shouldBreak = b;
        this.item = i;
        this.itemString = i.getId();
        this.block = i.asBlock();
        this.facing = f;
        this.optional = optional;
        this.predicate = predicate;
    }
    fun isImmediate(){
        return this.immediate;
    }
    fun setImmediate(bool){
        this.immediate = bool;
    }
    fun add(otherPos){
        return new WaitingTask(this.pos.add(otherPos), this.shouldBreak, this.item, this.facing, this.predicate);
    }
    fun hash(){
        return '' + this.pos + this.shouldBreak + this.itemString + this.facing;
    }
    fun isDone(){
    // null returns for nothing required
        if(this.isExecuted){
            return null;
        }
        return this;
    }
    fun internalAssertItem(){
        if (this.shouldBreak){
            if (isBlockInstantBreakable(this.pos.asPos())){
                return true;
            }
            return assertTool();
        }
        return assertItem(this.itemString);
    }
    fun checkInventory(){
        if (this.shouldBreak){
            return checkPickaxe();
        }
        return checkItem(this.itemString);
    }
    fun internalCanProcess(){
        if ((this.pos.isNear(player, playerReach) || this.ignoreDistance) && this.predicate()){
         if (trustClient || this.internalAssertItem())
            return true;
        }
        return false;
        //returns if player has item or tool and reach
    }
    fun isAvailable(){
        //external access
        if (this.isImmediate()){
            return this.predicate();
        }
        return (this.pos.isNear(player, playerReach) || this.ignoreDistance) && this.checkInventory() && (this.shouldBreak || requiredOffsetCheck(this.pos, this.itemString, this.facing)) && this.predicate() ;
    }
    fun process(){
    // checks, returns if processed
        if (this.internalCanProcess()){
            if(trustClient){
                this.internalAssertItem();
            }
            if (!this.immediate){
                sleep(taskInterval);
            }
            else {
                sleep(immediateInterval);
            }
            messageHolder.sendDebugMessage(this.formatted());
            if (this.shouldBreak){
                breakBlock(this.pos.asPos(), carefulBreakSneak);
                this.isExecuted = true;
                messageHolder.sendDebugMessage(this.formattedSuccess());
                return true;
            }

            result = placeDirectionBlock(this.pos.asPos(),this.itemString, this.facing, this.isImmediate());
            if (result){
                this.isExecuted = true;
                messageHolder.sendDebugMessage(this.formattedSuccess());
                return true;
            }
            else {
                messageHolder.sendMessage(this.formattedError());
            }
        }
        return false;
    }
    fun finish(){
        while (true){
            messageHolder.sendDebugMessage(this.formatted());
            pendingTask = this.isDone();
            if (pendingTask != null){
                if (!pendingTask.checkInventory()){
                    messageHolder.sendMessage(pendingTask.formattedError());
                    break;
                }
                result = pendingTask.process();
                if (result){
                    if (trustClient){
                        if (this != pendingTask){
                            if (!pendingTask.checkInventory()){
                                messageHolder.sendMessage(this.formattedError());
                                break;
                            }
                            this.process();
                        }
                        break;
                    }
                    else {
                        sleep(serverPing);
                    }

                }
            }
            else {
                break;
            }
        }
    }
    fun formattedError(){
        if (this.shouldBreak){
            return 'failed to break block at '+ this.pos.formatted();
        }
        return 'failed to place ' + this.itemString + ' at ' + this.pos.formatted() + ' with predicate ' + this.facing;
    }
    fun formatted(){
        if (this.shouldBreak){
            return 'break block at '+ this.pos.formatted();
        }
        return 'place ' + this.itemString + ' at ' + this.pos.formatted() + ' with predicate ' + this.facing;
    }
    fun formattedSuccess(){
        if (this.shouldBreak){
            return 'broke block at '+ this.pos.formatted() + ' at' + getMilliTime();
        }
        return 'placed ' + this.itemString + ' at ' + this.pos.formatted()+ ' with predicate at ' + this.facing + getMilliTime();
    }
    fun copy(){
        return new WaitingTask(this.pos.copy(), this.shouldBreak, this.item, this.facing,this.predicate, this.optional + 1);
    }
}


//Piston Utils, only implements static methods.
class PistonUtils{
    static fun canExtend(world, pos, facing){
        return world.getBlockAt(pos.offset(facing).asPos()).isReplaceable() && world.getBlockAt(pos.asPos()).isReplaceable();
    }
    static fun canPlaceTorchPoweringPiston(world, pos, facing){
    //returns Facing of Torch
        if (!world.getBlockAt(pos.asPos()).isReplaceable() ){
            return null;
        }
        foreach (direction : Direction.values()){
            if (direction == facing){
                continue;
            }
            if (direction.axis == Axis.Y){
                clickPos = blockPos.down();
                if (!world.getBlockAt(clickPos.asPos()).sideCoversSmallSquare(Direction.UP)){
                    continue;
                }
            }
            else {
                clickPos = blockPos.offset(torchFacing.getOpposite());
                if (!world.getBlockAt(clickPos.asPos()).sideCoversSmallSquare(facing.fromString) ){
                    continue;
                }
            }
            return direction;
        }
        return null;
    }
    static fun getHorizontalQcCheck(world, offsetFromPiston, pistonPos, pistonFacing){
        // returns new PosWithDirection(startPos, validFacing)
        // piston offset as 'startPos', then check with rotations and offset, to power piston.
        // means this function just iterates over piston's one side to get powering torch postion.
        startPos = pistonPos.offset(offsetFromPiston); //we offset from piston with direction, and this direction is restricted
	    if(PistonUtils.requiredOffsetCheck(world, startPos, 'torch', Direction.DOWN) && PistonUtils.willPowerPiston(startPos, Direction.DOWN, pistonPos, pistonFacing)) {
            return new PosWithDirection(startPos, Direction.DOWN);
	    }
	    foreach (torchTestFacing : Direction.values()){
	        if (torchTestFacing == Direction.UP || offsetFromPiston == torchTestFacing || offsetFromPiston == pistonFacing ) {
	            continue; //restricted
	        }
	    	foreach(offB : [0,1]){
	    		torchPos = startPos.up(offB);
	    		torchAble = PistonUtils.requiredOffsetCheck(world, torchPos, 'torch', torchTestFacing);
	    		if(torchAble && PistonUtils.willPowerPiston(torchPos, torchTestFacing, pistonPos, pistonFacing)) {
	    			return new PosWithDirection(torchPos, torchTestFacing);
	    	    }
	    	}
	    }
	    return null;
    }
    static fun calculateValidTorchPos(world, pistonPos, pistonFacing){
        foreach (directions : Direction.horizontal() ){
            result = PistonUtils.getHorizontalQcCheck(world, directions, pistonPos, pistonFacing);
            if (result != null){
                return result;
            }
            if (!pistonFacing == Direction.UP && PistonUtils.requiredOffsetCheck(world, pistonPos.up(), 'torch', directions)){
                return new PosWithDirection(pistonPos.up(), directions);
            }
        }
        if (pistonFacing != Direction.DOWN && PistonUtils.checkCanPlaceAt(world, pistonPos.down(), ItemStack.of(Material.of('torch')).asBlock())){
            return new PosWithDirection(pistonPos.down(), Direction.DOWN);
        }
    }
    static fun calculateBreakingPiston(world, blockPos){
        foreach ( directions : Direction.values()){
            pistonPos = blockPos.offset(directions);
            finalFacing = directions.getOpposite();
            foreach ( pistonFacing : Direction.values()){
                if (finalFacing == pistonFacing || !PistonUtils.canExtend(world, pistonPos, pistonFacing)){
                    continue;
                }
                result = PistonUtils.calculateValidTorchPos(world, pistonPos, pistonFacing);
                if (result != null && PistonUtils.willPowerPiston(new PosWithFun(result.asPos()), result.direction, pistonPos, finalFacing)){
                    return new RecordPiston(pistonFacing, finalFacing, result.direction, pistonPos, new PosWithFun(result.asPos()));
                }
            }
        }
        return null;
    }
    static fun calculateBreakingPiston(world, blockPos, finalFacing){
        foreach ( directions : [finalFacing]){
            pistonPos = blockPos.offset(finalFacing.getOpposite());
            finalFacing = directions;
            foreach ( pistonFacing : Direction.values()){
                if (finalFacing == pistonFacing || !PistonUtils.canExtend(world, pistonPos, pistonFacing)){
                    continue;
                }
                result = PistonUtils.calculateValidTorchPos(world, pistonPos, pistonFacing);
                if (result != null && PistonUtils.willPowerPiston(new PosWithFun(result.asPos()), result.direction, pistonPos, finalFacing)){
                    return new RecordPiston(pistonFacing, finalFacing, result.direction, pistonPos, new PosWithFun(result.asPos()));
                }
            }
        }
        return null;
    }
    static fun willPowerPiston(posTorch, faceTorch, posPiston, facePiston){
	    if (posPiston.offset(facePiston).equals(posTorch)) {
	        return false;
	    }
	    if (faceTorch.axis != Axis.Y && (posTorch.offset(faceTorch.getOpposite()).equals(posPiston) || posTorch.offset(faceTorch.getOpposite()).equals(posPiston.up()))){
	        return false;
	    }
	    if (posPiston.up().equals(posTorch) && faceTorch.axis != Axis.Y){
	        return false;
	    }
	    if ( posPiston.down().equals(posTorch) ){
	        return true;
	    }
	    if (facePiston.axis == Axis.Y){
	        foreach ( directions : Direction.horizontal()){
	            foreach (offsets : [0,1]){
	                off = posPiston.offset(directions).offset(Direction.UP, offsets);
	                if ( off.equals(posTorch)){
	                    return true;
	                }
	            }
	        }
	    }
	    foreach ( directions : Direction.horizontal()){
	        foreach ( offsets : [0,1]){
	            if (offsets == 0 && directions == facePiston && posPiston.offset(directions).equals(posTorch)){
	                return false;
	            }
	            off = posPiston.offset(directions).offset(Direction.UP, offsets);
	            if (off.equals(posTorch)){
	                return true;
	            }
	        }
	    }
	    return false;
    }
    static fun requiredOffsetCheck(world, blockPos, itemString, torchFacing){
        //WallMountedBlock, we need library maybe?
        if (torchFacing == Direction.NONE){
            torchFacing = Direction.DOWN;
        }
        if (itemString.contains('torch') && torchFacing.axis != Axis.Y){
            clickPos = blockPos.offset(torchFacing.getOpposite());
            if (!world.getBlockAt(clickPos.getX(),clickPos.getY(),clickPos.getZ()).isReplaceable() || !world.getBlockAt(clickPos.getX(),clickPos.getY(),clickPos.getZ()).sideCoversSmallSquare(torchFacing.getName()) || world.getBlockAt(clickPos.asPos()).getId() == pistonItem){
                return false;
            }
        }
        else {
            if (world.getBlockAt(blockPos.down().asPos()).getId().contains('piston')){
                return false; //Avoid PISTON - Torch at head because it can be used elsewhere
            }
            return PistonUtils.checkCanPlaceAt(world, blockPos, ItemStack.of(Material.of(itemString)).asBlock());
        }
        return true;
    }
    static fun checkCanPlaceAt(world, position, block){
        if (!world.getBlockAt(position.asPos()).isReplaceable()){
            return false;
        }
        jBlock = Java.valueOf(block); //blockState
        jWorld = Java.valueOf(world);
        jPosition = position.asJavaPos();
        return jBlock.getBlock().canPlaceAt(jBlock, jWorld, jPosition).toArucas();
    }
}

class RecordPiston{
    var pistonFacing;
    var finalFacing;
    var torchFacing;
    var pistonPos;
    var torchPos;
    RecordPiston(pistonFacing, pistonFinalFacing, torchFacing, pistonPos, torchPos){
        this.pistonFacing = pistonFacing;
        this.finalFacing = pistonFinalFacing;
        this.torchFacing = torchFacing;
        this.pistonPos = pistonPos;
        this.torchPos = torchPos;
    }
    fun formatted(){
        return 'Piston at '+ this.pistonPos.formatted() + ' with initial facing ' + this.pistonFacing.getName() + ' with final facing ' + this.finalFacing.getName() + '\nTorch at ' + this.torchPos.formatted() + ' with facing '+ this.torchFacing.getName();
    }
}

class CyclicTaskGenerator {
    var previousTask = null;
    var currentTask = null;
    var nextTask = null;
    var ListOfTask;
    var blockPos;
    var pointer;
    var length;
    var blockSize;
    var cycle = 0;
    var mapping = null;
    var invalid = false;
    //tasks : [PosWithFun(), shouldBreak, item, facing],....
    CyclicTaskGenerator(tasks, originPos){
        this.ListOfTask = tasks;
        this.blockPos = new PosWithFun(originPos);
        this.length = len(tasks);
        this.blockSize = this.preCalculateBlockSize();
        this.pointer = 0;
    }
    CyclicTaskGenerator(originPos){
        this.ListOfTask = [];
        this.blockPos = new PosWithFun(originPos);
        this.length = 0;
        this.blockSize = new PosWithFun(0,0,0);
        this.pointer = 0;
    }
    fun preCalculateBlockSize(){
        // get minX Y Z maxX Y Z
        minPos = new PosWithFun(0,0,0);
        maxPos = new PosWithFun(0,0,0);
        foreach(tasks : this.ListOfTask){
            minPos = minPos.getMinPos(tasks.pos);
            maxPos = maxPos.getMaxPos(tasks.pos);
        }
        return maxPos.subtract(minPos).add(new PosWithFun(1,1,1));
    }
    fun poll(){
        if (this.currentTask != null && !this.currentTask.isAvailable() && !this.currentTask.isExecuted){
            return null;
        }
        this.previousTask = this.currentTask;
        if (this.pointer == this.length){
            this.pointer = 0;
            this.cycle ++;
        }
        //position
        this.currentTask = this.ListOfTask.get(this.pointer).add(this.blockPos.add(this.blockSize.mult(this.cycle)));
        this.pointer++;
        if (this.currentTask.isAvailable())
            return this.currentTask;
        return null;
    }
    fun pollSafely(){
        //returns null if its okay, task if it should do something
        pendingTask = null;
        if (this.previousTask != null){
            pendingTask = this.previousTask.isDone();
            new ClickTask(this.previousTask.pos).fix();
        }
        else {
            pendingtask = null;
        }
        if (pendingTask == null){
            return this.poll();
        }
        return pendingTask;
    }
    fun execute(){
        awaitingTask = this.pollSafely();
        if (awaitingTask != null){
            awaitingTask.finish();
            return true;
        }
        return false;
    }
    fun abortIfInvalid(){
        return;
    }
    fun addAction(position, itemstring, direction, shouldBreak){
        if(this.mapping != null){
            if(this.mapping.get(itemstring) != null){
                itemstring = this.mapping.get(itemstring);
            }
        }
        this.length ++;
        this.ListOfTask.append(new Task(new PosWithFun(position), shouldBreak, itemstring, direction));
    }
    fun addAction(task){
        this.length ++;
        this.ListOfTask.append(task);
    }
    fun adjustOrigin(newOrigin){
        this.blockPos = new PosWithFun(newOrigin);
    }
    fun attachMapping(mapping){
        this.mapping = mapping;
    }
    fun getDiagonal(direction){
        blockPos = new PosWithFun(0,0,0);
        this.mapping = Mapping_Diagonal;
        if (this.mapping != null){
            yClockwise = direction.rotateYClockwise();
            this.addAction(blockPos.offset(direction).offset(yClockwise).offset(direction), 0, yClockwise, false); //place rail
            this.addAction(blockPos.offset(direction).offset(yClockwise).offset(yClockwise), 0, yClockwise, false);
            this.addAction(blockPos.offset(direction).offset(yClockwise), 0, yClockwise, false);//place rail
            this.addAction(blockPos.offset(direction).offset(yClockwise).offset(direction), 0, yClockwise, true); //break rail
            this.addAction(blockPos.offset(direction).offset(yClockwise).offset(yClockwise), 0, yClockwise, true);//break rail
            this.addAction(blockPos.offset(direction).offset(yClockwise).offset(direction,2), 7, yClockwise, false); //block for pushing
            this.addAction(blockPos.offset(direction).offset(yClockwise).offset(yClockwise,2), 7, yClockwise, false); //block for pushing
            this.addAction(blockPos.offset(direction).offset(yClockwise).offset(direction,3), 3, yClockwise, false); //piston
            this.addAction(blockPos.offset(direction).offset(yClockwise).offset(yClockwise,3), 3, direction, false); //piston
            this.addAction(blockPos.offset(direction).offset(yClockwise).offset(direction,4), 4, yClockwise, false); //powerable
            this.addAction(blockPos.offset(direction).offset(yClockwise).offset(yClockwise,4), 4, yClockwise, false); //powerable
            this.addAction(blockPos.offset(direction).offset(yClockwise).offset(direction,5), 2, direction.getOpposite(), false); //repeater
            this.addAction(blockPos.offset(direction).offset(yClockwise).offset(yClockwise,5), 2, yClockwise.getOpposite(), false);; //repeater
            this.addAction(blockPos.offset(direction).offset(yClockwise).offset(direction,6), 4, yClockwise, false); //powerable
            this.addAction(blockPos.offset(direction).offset(yClockwise).offset(yClockwise,6), 4, yClockwise, false); //powerable
            this.addAction(blockPos.offset(direction,2).offset(yClockwise,2).offset(direction), 0, yClockwise, false); //place rail
            this.addAction(blockPos.offset(direction,2).offset(yClockwise,2).offset(yClockwise), 0, yClockwise, false);//place rail
            this.addAction(blockPos.offset(direction,2).offset(yClockwise,2), 0, yClockwise, false);//place rail
            this.addAction(blockPos.offset(direction,2).offset(yClockwise,2).offset(direction), 0, yClockwise, true); //break rail
            this.addAction(blockPos.offset(direction,2).offset(yClockwise,2).offset(yClockwise), 0, yClockwise, true); //break rail
            this.addAction(blockPos.offset(direction,2).offset(yClockwise,2).offset(direction,2), 7, yClockwise, false); //block for pushing
            this.addAction(blockPos.offset(direction,2).offset(yClockwise,2).offset(yClockwise,2), 7, yClockwise, false); //block for pushing
            this.addAction(blockPos.offset(direction,2).offset(yClockwise,2).offset(direction,3), 3, yClockwise, false); //piston
            this.addAction(blockPos.offset(direction,2).offset(yClockwise,2).offset(yClockwise,3), 3, direction, false); //piston
            this.addAction(blockPos.offset(direction,2).offset(yClockwise,2).offset(direction,5), 6, direction, false); //dust
            this.addAction(blockPos.offset(direction,2).offset(yClockwise,2).offset(yClockwise,5), 6, direction, false); //dust
            this.addAction(blockPos.offset(direction).offset(yClockwise).offset(direction,3).up(), 5, Direction.DOWN, false); //carpet
            this.addAction(blockPos.offset(direction).offset(yClockwise).offset(yClockwise,3).up(), 5, Direction.DOWN, false); //carpet
            this.addAction(blockPos.offset(direction).offset(yClockwise).offset(direction,4).up(), 5, Direction.DOWN, false); //carpet
            this.addAction(blockPos.offset(direction).offset(yClockwise).offset(yClockwise,4).up(), 5, Direction.DOWN, false); //carpet
            this.addAction(blockPos.offset(direction).offset(yClockwise).offset(direction,6).up(), 5, Direction.DOWN, false); //carpet
            this.addAction(blockPos.offset(direction).offset(yClockwise).offset(yClockwise,6).up(), 5, Direction.DOWN, false); //carpet
            this.addAction(blockPos.offset(direction,2).offset(yClockwise,2).offset(direction,3).up(), 5, Direction.DOWN, false); //carpet
            this.addAction(blockPos.offset(direction,2).offset(yClockwise,2).offset(yClockwise,3).up(), 5, Direction.DOWN, false); //carpet
            this.blockSize = new PosWithFun(0,0,0).offset(direction, 2).offset(yClockwise,2);
            }
    }
    fun getStraightV1(direction){
            this.mapping = Mapping_Straight;
            blockPos = new PosWithFun(0,0,0);
            yClockwise = direction.rotateYClockwise();
            yCounterClockwise = direction.rotateYCounterclockwise();
            if (direction .equals( EAST) || direction .equals( SOUTH)) {
                    this.addAction(blockPos.offset(direction).offset(yClockwise), 0, yClockwise, false);//place rail
                    this.addAction(blockPos.offset(direction).offset(direction), 0, direction, false);//place rail
                    this.addAction(blockPos.offset(direction), 0, direction, false);//place rail
                    this.addAction(blockPos.offset(direction).offset(yClockwise), 0, yClockwise, true);//break rail
                    this.addAction(blockPos.offset(direction).offset(direction), 0, direction, true);//break rail
                    this.addAction(blockPos.offset(direction).offset(direction).offset(yCounterClockwise), 0, yCounterClockwise, false);//place rail
                    this.addAction(blockPos.offset(direction).offset(direction).offset(direction), 0, direction, false);//place rail
                    this.addAction(blockPos.offset(direction).offset(direction), 0, direction, false);//place rail
                    this.addAction(blockPos.offset(direction).offset(direction).offset(yCounterClockwise), 0, yCounterClockwise, true);//break rail
                    this.addAction(blockPos.offset(direction).offset(direction).offset(direction), 0, direction, true);//break rail
                    this.addAction(blockPos.offset(direction).offset(yCounterClockwise), 3, direction, false); //place piston, facing east
                    this.addAction(blockPos.offset(direction).offset(direction).offset(yClockwise), 3, direction, false); //place piston, facing east
                    this.addAction(blockPos.offset(direction).offset(yCounterClockwise).offset(yCounterClockwise), 4, direction, false); //place powerableBlock
                    this.addAction(blockPos.offset(direction).offset(direction).offset(yClockwise).offset(yClockwise), 4, direction, false); //place powerableBlock
                    this.addAction(blockPos.offset(direction).offset(direction).offset(yCounterClockwise).offset(yCounterClockwise), 2, direction.getOpposite(), false); //place repeater, facing east
                    this.addAction(blockPos.offset(direction).offset(yClockwise).offset(yClockwise), 2, direction.getOpposite(), false); //place repeater, facing east
                    this.addAction(blockPos.offset(direction).offset(yCounterClockwise).up(), 5, Direction.DOWN, false); //place carpet
                    this.addAction(blockPos.offset(direction).offset(direction).offset(yClockwise).up(), 5, Direction.DOWN, false);; //place carpet
                    this.addAction(blockPos.offset(direction).offset(yCounterClockwise).offset(yCounterClockwise).up(), 5, Direction.DOWN, false); //place carpet
                    this.addAction(blockPos.offset(direction).offset(direction).offset(yClockwise).offset(yClockwise).up(), 5, Direction.DOWN, false); //place carpet
                    }//new
            if (direction .equals( WEST) || direction .equals( NORTH)){
                    this.addAction(blockPos.offset(direction).offset(yCounterClockwise), 1, Direction.DOWN, false); //place torch
                    this.addAction(blockPos.offset(direction).offset(yClockwise), 0, yClockwise, false);//place rail
                    this.addAction(blockPos.offset(direction).offset(direction), 0, direction, false);//place rail
                    this.addAction(blockPos.offset(direction), 0, direction, false);//place rail
                    this.addAction(blockPos.offset(direction).offset(yClockwise), 0, yClockwise, true);//break rail
                    this.addAction(blockPos.offset(direction).offset(direction), 0, direction, true);//break rail
                    this.addAction(blockPos.offset(direction).offset(yCounterClockwise), 1, Direction.DOWN, true); //break torch
                    this.addAction(blockPos.offset(direction).offset(direction).offset(yClockwise), 1, Direction.DOWN, false); //place torch
                    this.addAction(blockPos.offset(direction).offset(direction).offset(yCounterClockwise), 0, yCounterClockwise, false);//place rail
                    this.addAction(blockPos.offset(direction).offset(direction).offset(direction), 0, direction, false);//place rail
                    this.addAction(blockPos.offset(direction).offset(direction), 0, direction, false);//place rail
                    this.addAction(blockPos.offset(direction).offset(direction).offset(yCounterClockwise), 0, yCounterClockwise, true);//break rail
                    this.addAction(blockPos.offset(direction).offset(direction).offset(direction), 0, direction, true);//break rail
                    this.addAction(blockPos.offset(direction).offset(direction).offset(yClockwise), 1, Direction.DOWN, true); //break torch
                    this.addAction(blockPos.offset(direction).offset(yCounterClockwise), 3, direction, false); //place piston, facing east
                    this.addAction(blockPos.offset(direction).offset(direction).offset(yClockwise), 3, direction, false); //place piston, facing east
                    this.addAction(blockPos.offset(direction).offset(yCounterClockwise).offset(yCounterClockwise), 4, direction, false); //place powerableBlock
                    this.addAction(blockPos.offset(direction).offset(direction).offset(yClockwise).offset(yClockwise), 4, direction, false); //place powerableBlock
                    this.addAction(blockPos.offset(direction).offset(direction).offset(yCounterClockwise).offset(yCounterClockwise), 2, direction.getOpposite(), false); //place repeater, facing east
                    this.addAction(blockPos.offset(direction).offset(yClockwise).offset(yClockwise), 2, direction.getOpposite(), false); //place repeater, facing east
                    this.addAction(blockPos.offset(direction).offset(yCounterClockwise).offset(yCounterClockwise).up(), 5, Direction.DOWN, false); //place carpet
                    this.addAction(blockPos.offset(direction).offset(direction).offset(yClockwise).offset(yClockwise).up(), 5, Direction.DOWN, false);; //place carpet
                    this.addAction(blockPos.offset(direction).offset(yCounterClockwise).up(), 5, Direction.DOWN, false); //place carpet
                    this.addAction(blockPos.offset(direction).offset(direction).offset(yClockwise).up(), 5, Direction.DOWN, false); //place carpet;//new
            }
            this.blockSize = blockPos.offset(direction).offset(direction);
    }
    fun getStraightV2(direction){
            this.mapping = Mapping_Straight_v2;
            blockPos = new PosWithFun(0,0,0);
            yClockwise = direction.rotateYClockwise(); //right
            yCounterClockwise = direction.rotateYCounterclockwise(); //left
            this.addAction(blockPos.offset(yClockwise, 2).offset(direction), 4, direction, false); //4 powerableblock
            this.addAction(blockPos.offset(yCounterClockwise, 2).offset(direction), 4, direction, false);
            this.addAction(blockPos.offset(yClockwise).offset(direction), 3, direction, false); //piston
            this.addAction(blockPos.offset(yClockwise).offset(direction).up(), 0, direction, false); //rail
            this.addAction(blockPos.offset(direction, 2), 0, direction, false); //rail temporary
            if (direction.equals(NORTH) || direction.equals(WEST)){
                //we need torch
                this.addAction(blockPos.offset(direction, -1).offset(yClockwise),  1,Direction.DOWN, true); //torch breaking
                this.addAction(blockPos.offset(direction).offset(yCounterClockwise),  1,UP, false); //torch
            }
            this.addAction(blockPos.offset(direction), 0, direction, false); //rail will be curved
            this.addAction(blockPos.offset(direction, 0).offset(yClockwise), 8, Direction.DOWN, true); //Now we can remove temporary powered rail
            this.addAction(blockPos.offset(yClockwise, 2).offset(direction, 2), 2, direction.getOpposite(), false);
            this.addAction(blockPos.offset(yCounterClockwise, 2).offset(direction, 2), 2, direction.getOpposite(), false); //repeater
            this.addAction(blockPos.offset(direction, 2), 0, Direction.DOWN, true); //break rail
            this.addAction(blockPos.offset(direction, 2).offset(yCounterClockwise), 8, yCounterClockwise, false); //place temporary powered rail
            this.addAction(blockPos.offset(direction, 2), 8, yCounterClockwise, false); // place powered rail
            this.addAction(blockPos.offset(yClockwise).offset(direction).up(), 0, Direction.DOWN, true); //break rail on piston
            //half
            this.addAction(blockPos.offset(yClockwise, 2).offset(direction,3), 4, direction, false); //4 powerableblock
            this.addAction(blockPos.offset(yCounterClockwise, 2).offset(direction,3), 4, direction, false);
            this.addAction(blockPos.offset(yCounterClockwise).offset(direction, 3), 3, direction, false); //piston
            this.addAction(blockPos.offset(yCounterClockwise).offset(direction, 3).up(), 0, yCounterClockwise, false); //rail
            this.addAction(blockPos.offset(direction, 4), 0, direction, false); //rail temporary
            if (direction.equals(NORTH) || direction.equals(WEST)){
                //we need torch
                this.addAction(blockPos.offset(direction).offset(yCounterClockwise),  1,Direction.DOWN, true); //torch breaking
                this.addAction(blockPos.offset(direction, 3).offset(yClockwise),  1, Direction.UP, false); //torch placing
            }
            this.addAction(blockPos.offset(direction, 3), 0, direction, false); //rail will be curved
            this.addAction(blockPos.offset(direction, 2).offset(yCounterClockwise), 8, Direction.DOWN, true); //Now we can remove temporary powered rail
            this.addAction(blockPos.offset(yClockwise, 2).offset(direction, 4), 2, direction.getOpposite(), false);
            this.addAction(blockPos.offset(yCounterClockwise, 2).offset(direction, 4), 2, direction.getOpposite(), false); //repeater
            this.addAction(blockPos.offset(direction, 4).offset(yClockwise), 8, yCounterClockwise, false); //place temporary powered rail
            this.addAction(blockPos.offset(direction, 4), 0, Direction.DOWN, true); //rail temporary remove
            this.addAction(blockPos.offset(direction, 4), 8, yClockwise, false); //powered rail
            this.addAction(blockPos.offset(yCounterClockwise).offset(direction, 3).up(), 0, Direction.DOWN, true); //rail
            this.blockSize = blockPos.offset(direction, 4);
    }
}

class TaskIterator {
    //Single-use task container
    var currentTask = null;
    var ListOfTask;
    var blockPos;
    var pointer;
    var length;
    var blockSize;
    var cycle = 0;
    var mapping = null;
    var invalid = false;
    //tasks : [PosWithFun(), shouldBreak, item, facing],....
    TaskIterator(tasks, originPos){
        this.ListOfTask = tasks;
        this.blockPos = new PosWithFun(originPos);
        this.length = len(tasks);
        this.pointer = 0;
    }
    TaskIterator(){
        this.ListOfTask = [];
        this.length = 0;
    }
    TaskIterator(originPos){
        this.blockPos = new PosWithFun(originPos);
        this.ListOfTask = [];
        this.length = 0;
    }
    fun isNear(other, allowDistance){
        if (this.blockPos == null || other.blockPos == null){
            return true;
        }
        return this.blockPos.distanceTo(other.blockPos) <= allowDistance;
    }
    fun pollSafely(){
        //get Any task that can be executed
        i = 0;
        foreach (tasks : this.ListOfTask){
            pendingTask = tasks.isDone();
            if (pendingTask != null && pendingTask.isAvailable()){
                this.currentTask = pendingTask;
                this.ListOfTask.remove(i);
                this.length--;
                return this.currentTask;
            }
            i++;
        }
        return null;
    }
    fun execute(){
        awaitingTask = this.pollSafely();
        if (awaitingTask != null){
            awaitingTask.finish();
            return true;
        }
        return false;
    }
    fun abortIfInvalid(){
        return;
    }
    fun addAction(position, itemstring, direction, shouldBreak){
        if(this.mapping != null){
            if(this.mapping.get(itemstring) != null){
                itemstring = this.mapping.get(itemstring);
            }
        }
        this.length ++;
        this.ListOfTask.append(new Task(position, shouldBreak, itemstring, direction));
    }
    fun addAction(action){
        this.length ++;
        this.ListOfTask.append(action);
    }
    fun attachMapping(mapping){
        this.mapping = mapping;
    }
    fun len(){
        return this.length;
    }
}
class LeftOverProcessingTask {
    //holds positions of block that must be air
    var tasks = {};
    LeftOverProcessingTask(){

    }
    fun addPos(pos){
        this.tasks.put(pos, getMilliTime());
    }
    fun process(){
        this.clearKeys();
        foreach(t : this.tasks.getKeys()){
            if (this.tasks.get(t) + 300 < getMilliTime()){
                if (t.isNear(player, playerReach))
                {
                    messageHolder.sendDebugMessage(t.formatted());
                    breakBlock(t, false);
                }

            }
        }
    }
    fun clearKeys(){
        foreach(t : this.tasks.getKeys()){
            if (world.getBlockAt(t.asPos()).isReplaceable()){
                this.tasks.remove(t);
            }
        }
    }
}
class BedrockBreakingTaskSeparator {
    //Sets of task when bunch of bedrock breaking task is present
    //yields executable when ALL positions are in range, and wait until yielded task is finished
    var iterators = []; //we exepect Positions in container
    var holding = null;
    var holdingPos = null;
    var bedrockPos = null;
    var pointer = null;
    BedrockBreakingTaskSeparator(){
    }
    BedrockBreakingTaskSeparator(fromList){
        this.iterators = fromList.copy();
    }
    fun addAll(startPos, endPos){
        foreach (positions : world.getPositions(startPos, endPos)){
             if(this.checkValidPos(positions)){
                this.iterators.append(new PosWithFun(positions));
             }
        };
    }
    fun checkValidPos(pos){
        return world.getBlockAt(pos).getHardness() == -1 && !world.getBlockAt(pos).getId().contains(pistonItem);
    }
    fun generateResult(pos){
        recordPiston = PistonUtils.calculateBreakingPiston(world, pos);
        if (recordPiston != null){
            //messageHolder.sendDebugMessage(recordPiston.formatted());
            return chainedPistonTaskRecord(recordPiston, false);
        }
        return null;
    }
    fun generateResultRegister(pos){
        recordPiston = PistonUtils.calculateBreakingPiston(world, pos);
        if (recordPiston != null){
            this.holdingPos = recordPiston.pistonPos;
            this.bedrockPos = pos;
            messageHolder.sendMessageUnique(recordPiston.formatted());
            return chainedPistonTaskRecord(recordPiston, false);
        }
        return null;
    }
    fun canYieldAny(){
        foreach ( positions : this.iterators){
            if (!this.checkValidPos(pos.asPos())){
                continue;
            }
            taskIterators = this.generateResult(positions);
            if (taskIterators != null && taskIterators.isAllNear()){
                return true;
            }
        }
        return false;
    }
    fun poll(){
        this.checkFinished();
        if (this.holding != null && !this.holding.isFinished() || this.holdingPos != null && !world.isAir(this.holdingPos.asPos())){
            return null;
        }
        i = 0;
        foreach ( positions : this.iterators){
            if (!this.checkValidPos(positions.asPos())){
                messageHolder.sendDebugMessage("" + positions.asPos() + " is not valid pos to break, ignoring..." );
                i++;
                continue;
            }
            taskIterators = this.generateResultRegister(positions);
            if (taskIterators != null && taskIterators.isAllNear()){
                this.holding = taskIterators;
                this.pointer = i;
                messageHolder.sendDebugMessage("Holding bedrock breaking task for "+positions.formatted());
                return taskIterators;
            }
            i++;
        }
        return null;
    }
    fun checkFinished(){
        if (this.holding != null){
            if (this.holding.isFinished() ){
                sleep(65); //ghost blocks
                if (world.isAir(this.bedrockPos.asPos())){
                    this.iterators.remove(this.pointer);
                    messageHolder.sendDebugMessage("Finished bedrock breaking task for "+this.bedrockPos.formatted());
                }
                else {
                    messageHolder.sendDebugMessage("Failed bedrock breaking task for "+this.bedrockPos.formatted());
                }
                this.pointer = null;
                this.bedrockPos = null;
                this.holding = null;
            }
        }
    }
}

class SequencedTaskIterator {
    //Single-use task container
    var prettyPos = null;
    var currentTask = null;
    var returnedLastTask = null;
    var ListOfTask;
    var blockPos;
    var pointer = 0;
    var length = 0;
    var blockSize;
    var cycle = 0;
    var invalid = false;
    var mapping = null;
    var ignoreDistance = false;
    //tasks : [PosWithFun(), shouldBreak, item, facing],....
    SequencedTaskIterator(tasks, originPos){
        this.ListOfTask = tasks;
        this.blockPos = new PosWithFun(originPos);
        this.length = len(tasks);
        this.pointer = 0;
    }
    SequencedTaskIterator(){
        this.ListOfTask = [];
        this.length = 0;
    }
    SequencedTaskIterator(originPos){
        this.blockPos = new PosWithFun(originPos);
        this.ListOfTask = [];
        this.length = 0;
    }
    fun isNear(other, allowDistance){
        if (this.blockPos == null || other.blockPos == null){
            return true;
        }
        return this.blockPos.distanceTo(other.blockPos) < allowDistance;
    }
    fun isAllNear(allowDistance){
        if (this.ignoreDistance){
            return true;
        }
        foreach (tasks : this.ListOfTask){
            if (tasks.pos == null){
                continue;
            }
            if (!tasks.pos.isNear(player, allowDistance)){
                return false;
            }
        }
        return true;
    }
    fun isAllNear(){
        if (this.ignoreDistance){
            return true;
        }
        foreach (tasks : this.ListOfTask){
            if (tasks.pos == null){
                continue;
            }
            if (!tasks.pos.isNear(player, playerReach)){
                return false;
            }
        }
        return true;
    }
    fun pollSafely(){
        //get Any task that can be executed
        if(this.length <= 0 || this.length == this.pointer){
            return null;
        }
        //messageHolder.sendMessageUnique(this.ListOfTask);
        tasks = this.ListOfTask.get(this.pointer);
        while (tasks.isExecuted && this.pointer < this.length){
            this.pointer ++;
            tasks = this.ListOfTask.get(this.pointer);
        }
        if (this.length == this.pointer){
            return null;
        }
        if (tasks.isAvailable() && !tasks.isExecuted){
            this.currentTask = tasks;
            this.returnedLastTask = tasks;
            this.pointer ++;
            return tasks;
        }
        return null;
    }
    fun abortIfInvalid(){
        if (!this.isAllNear() || this.pollSafely() == null){
            messageHolder.sendDebugMessage(this.formatted() + ' is invalid ');
            this.invalid = true;
        }
    }
    fun execute(){
        this.ignoreDistance();
        awaitingTask = this.pollSafely();
        if (awaitingTask != null){
            messageHolder.sendDebugMessage('execute ' + awaitingTask.formatted());
            awaitingTask.finish();
            messageHolder.sendDebugMessage('executed ' + awaitingTask.formatted()+'\n');
            return true;

        }
        return false;
    }
    fun ignoreDistance(){
        this.ignoreDistance = true;
        //flags all tasks as distance verified
        foreach (tasks : this.ListOfTask){
            tasks.ignoreDistance = true;
        }
    }
    fun addAction(position, itemstring, direction, shouldBreak){
        if(this.mapping != null){
            if(this.mapping.get(itemstring) != null){
                itemstring = this.mapping.get(itemstring);
            }
        }
        this.length ++;
        this.ListOfTask.append(new Task(position, shouldBreak, itemstring, direction));
    }
    fun addAction(action){
        this.length ++;
        this.ListOfTask.append(action);
    }
    fun attachMapping(mapping){
        this.mapping = mapping;
    }
    fun len(){
        return this.length;
    }
    fun isFinished(){
        foreach ( task : this.ListOfTask){
            if (!task.isExecuted){
                return false;
            }
        }
        return true;
    }
    fun formatted(){
        ret = '';
        foreach ( task : this.ListOfTask){
            ret = ret+ task.formatted()+'\n';
        }
        if (this.prettyPos != null){
            return 'Task at '+ this.prettyPos.formatted() +'\n'+ ret;;
        }
        return ret;
    }
    fun abort(){

    }
}

class MovementTask{
    var sneak = false;
    var speed = 1;

}

class SpawnConditionCheck{
    var world;
    SpawnConditionCheck(world){
        this.world = world;
    }
    //returns position for block to be placed
    fun getZombieLightIgnored(pos){
        pos = new PosWithFun(pos);
        offsetBlock = this.world.getBlockAt(pos.down().asPos());
        if(!offsetBlock.isSpawnable()){
            doubleOffsetBlock = this.world.getBlockAt(pos.down(2).asPos());
            if (doubleOffsetBlock.isSpawnable() && this.isNonReplaceAirVariant(pos.down().asPos())){
                return this.returnIfReplaceable(pos.asPos());
            }
            //messageHolder.sendMessageUnique("Entity can't spawn at " + offsetBlock.getId() );
            return null;
        }
        if (Entity.of('minecraft:zombie').collidesWith(pos.asPos(), this.world.getBlockAt(pos.asPos()))){
            //messageHolder.sendMessageUnique("Entity will collide with block " + this.world.getBlockAt(pos.asPos()).getId() );
            return null;
        }
        if (world.getBlockAt(pos.asPos()).isReplaceable()){
            return this.returnIfReplaceable(pos.asPos());
        }
        if (world.getBlockAt(pos.up().asPos()).isReplaceable()){
            return this.returnIfReplaceable(pos.up().asPos());
        }
        return null;
    }
    fun getNormalSpawnProof(pos){
        pos = new PosWithFun(pos);
        if (!this.world.getBlockAt(pos.up().asPos()).isReplaceable()){
            return null;
        }
        blockId = this.world.getBlockAt(pos.down().asPos()).getId();
        if ( blockId == 'netherrack' || blockId == 'soul_sand'|| blockId == 'soul_soil'|| blockId.contains('ore')){
            return this.returnIfReplaceable(pos.asPos());
        }
        return null;
    }
    fun returnIfReplaceable(pos){
        if (this.world.getBlockAt(pos).isReplaceable()){
            return pos;
        }
        return null;
    }
    fun isZombieLightIgnoredPos(pos){
        p2 = this.getZombieLightIgnored(pos);
        if(p2 != null && pos == p2){
            return true;
        }
        return false;
    }
    fun isNonReplaceAirVariant(pos){
        block = this.world.getBlockAt(pos);
        id = block.getId();
        if (id.contains('torch') || id.contains('grass') || id.contains('flower')){
            return true;
        }
        return false;
    }
}
//spawnChecker.isZombieLightIgnoredPos(pos);
//Initialize Tasks

taskHolder = Set.of();
taskFunctionHolder = Set.of();
fillTask = fun ( x, y, z, ex, ey, ez, itemName) {
    taskIterator = new TaskIterator();
    if (itemName == 'air'){
        foreach (position : world.getPositions(new Pos(x,y,z), new Pos(ex,ey,ez))){
            taskIterator.addAction(position, 'Air', Direction.NONE, true);
        }
    }
    else {
        foreach (position : world.getPositions(new Pos(x,y,z), new Pos(ex,ey,ez))){
            taskIterator.addAction(position, itemName, Direction.NONE, false);
        }
    }
    taskHolder.add(taskIterator);
    messageHolder.sendDebugMessage('Added task length of '+taskIterator.len());
};
breakTask = fun ( x, y, z, ex, ey, ez) {
    taskIterator = new TaskIterator();
    foreach (position : world.getPositions(new Pos(x,y,z), new Pos(ex,ey,ez))){
        taskIterator.addAction(position, 'Air', Direction.NONE, true);
    }
    taskHolder.add(taskIterator);
    messageHolder.sendDebugMessage('Added task length of '+taskIterator.len());
};
breakBedrockAreaTask = fun (x,y,z,ex,ey,ez){
    startPos = new Pos(x,y,z);
    endPos = new Pos(ex,ey,ez);
    delayedHolder.addAll(startPos, endPos);
    messageHolder.sendMessage('Added task from '+ startPos + ' to '+ endPos);
};
setAreaPos1Task = fun (x,y,z){
    AreaPos1 = new Pos(x,y,z);
    messageHolder.sendMessage('located bedrock breaking start pos 1 to '+ AreaPos1);
};
setAreaPos1RayTraceTask = fun (){
    AreaPos1 = player.getLookingAtBlock().getPos();
    messageHolder.sendMessage('located bedrock breaking start pos 1 to '+ AreaPos1);
};
setAreaPos2Task = fun (x,y,z){
    AreaPos2 = new Pos(x,y,z);
    messageHolder.sendMessage('located bedrock breaking start pos 2 to '+ AreaPos2);
    if (AreaPos1 != null){
        delayedHolder.addAll(AreaPos1, AreaPos2);
        messageHolder.sendMessage('Added task from '+ AreaPos1 + ' to '+ AreaPos2);
        AreaPos1 = null;
        AreaPos2 = null;
    }
};
setAreaPos2RayTraceTask = fun (){
    AreaPos2 = player.getLookingAtBlock().getPos();
    messageHolder.sendMessage('located bedrock breaking start pos 2 to '+ AreaPos2);
    if (AreaPos1 != null){
        delayedHolder.addAll(AreaPos1, AreaPos2);
        messageHolder.sendMessage('Added task from '+ AreaPos1 + ' to '+ AreaPos2);
        AreaPos1 = null;
        AreaPos2 = null;
    }
};
fillDirectionTask = fun ( x, y, z, ex, ey, ez, itemName, direction) {
    taskIterator = new TaskIterator();
    direction = Direction.fromString(direction);
    if (!direction.isValid()){
        return null;
    }
    foreach (position : world.getPositions(new Pos(x,y,z), new Pos(ex,ey,ez))){
        taskIterator.addAction(position, itemName, direction, false);
    }
    taskHolder.add(taskIterator);
    messageHolder.sendDebugMessage('Added task length of '+taskIterator.len());
};
pauseTask = fun (){
    pause = !pause;
    messageHolder.sendMessageUnchecked(pause);
};
intervalChangeTask = fun(newInterval){
    sleepInterval = newInterval;
    messageHolder.sendMessageUnchecked('New interval : '+ newInterval + 'ms');
};
blockIntervalChangeTask = fun (newInterval){
    if(newInterval > 0){
        taskInterval = newInterval;
        messageHolder.sendMessageUnchecked('New interval between blocks: '+ newInterval + 'ms');
    }
};
serverPingChangeTask = fun (newInterval){
    if(newInterval > 0){
        serverPing = newInterval;
        messageHolder.sendMessageUnchecked('Server Ping Expected: '+ newInterval + 'ms');
    }
};
trustClientTask = fun (){
    trustClient = !trustClient;
    messageHolder.sendMessageUnchecked('Desync Trust : '+ trustClient );
};
toggleMessageTask = fun (){
    hideMessage = !hideMessage;
    messageHolder.sendMessageUnchecked('Hide message : '+ hideMessage );
};
toggleProtocolTask = fun (newVal){
    accurateBlockPlacement = newVal;
    messageHolder.sendMessageUnchecked('AccurateBlockPlacement : '+ accurateBlockPlacement );
};
demiBoltTask = fun(px, py, pz, direction){
    taskInterval = 50;
    direction = Direction.fromString(direction);
    if(direction.isValid()){
        t = new CyclicTaskGenerator(new PosWithFun(px, py, pz));
        t.getStraightV2(direction);
        taskHolder.add(t);
    }
    else {
        messageHolder.sendMessageUnchecked("Direction name was not valid");
    }
};
standardBoltTask = fun(px, py, pz, direction){
    taskInterval = 50;
    direction = Direction.fromString(direction);
    if(direction.isValid()){
        t = new CyclicTaskGenerator(new PosWithFun(px, py, pz));
        t.getStraightV1(direction);
        taskHolder.add(t);
    }
    else {
        messageHolder.sendMessageUnchecked("Direction name was not valid");
    }
};
diagonalBoltTask = fun(px, py, pz, direction){
    taskInterval = 50;
    direction = Direction.fromString(direction);
    if(direction.isValid()){
        t = new CyclicTaskGenerator(new PosWithFun(px, py, pz));
        t.getDiagonal(direction);
        taskHolder.add(t);
    }
    else {
        messageHolder.sendMessageUnchecked("Direction name was not valid");
    }
};
reachDistanceTask = fun (newVal){
    if(newVal > 0){
        playerReach = newVal;
        messageHolder.sendMessageUnchecked('New player reach distance : '+ newVal );
    }
};

breakingTask = fun (px, py, pz, headless){
    recordPiston = PistonUtils.calculateBreakingPiston(world, new PosWithFun(px, py, pz));
    if (recordPiston == null){
        messageHolder.sendMessageUnchecked("Can't break block with piston, no method found");
    }
    else {
        taskIterator = chainedPistonTaskRecord(recordPiston, headless);
        taskHolder.add(taskIterator);
    }
};

breakingLookingAtTask = fun (){
    pos = player.getLookingAtBlock();
    recordPiston = PistonUtils.calculateBreakingPiston(world, new PosWithFun(pos));
    if (recordPiston == null){
        messageHolder.sendMessageUnchecked("Can't break block with piston, no method found");
    }
    else {
        taskIterator = chainedPistonTaskRecord(recordPiston, false);
        taskHolder.add(taskIterator);
    }
};
breakingLookingAtHeadlessTask = fun (direction, headless){
    direction = Direction.fromString(direction);
    if (!direction.isValid()) {
        messageHolder.sendMessageUnchecked("Direction name was not valid");
        return;
    }
    pos = player.getLookingAtBlock();
    recordPiston = PistonUtils.calculateBreakingPiston(world, new PosWithFun(pos), direction);
    if (recordPiston == null){
        messageHolder.sendMessageUnchecked("Can't break block with piston, no method found");
    }
    else {
        taskIterator = chainedPistonTaskRecord(recordPiston, headless);
        taskHolder.add(taskIterator);
    }
};
headlessTask = fun (px, py, pz, direction, headless){
    direction = Direction.fromString(direction);
    if(direction.isValid()){
        recordPiston = PistonUtils.calculateBreakingPiston(world, new PosWithFun(px, py, pz), direction);
        if (recordPiston == null){
            messageHolder.sendMessageUnchecked("Can't break block with piston, no method found");
        }
        else {
            taskIterator = chainedPistonTaskRecord(recordPiston, headless);
            taskHolder.add(taskIterator);
        }
    }
    else {
        messageHolder.sendMessageUnchecked("Direction name was not valid");
    }
};
diagonalUpTask = fun (px, py, pz, direction, itemString){
    direction = Direction.fromString(direction);
    if(!direction.isValid()){
        messageHolder.sendMessageUnchecked("Direction name was not valid");
        return;
    }
    diagonalUpTasks = new CyclicTaskGenerator(new PosWithFun(px,py,pz));
    diagonalUpTasks.addAction(new Task(new PosWithFun(0,0,0), itemString, null));
    diagonalUpTasks.blockSize = new PosWithFun(0,1,0).offset(direction);
    taskHolder.add(diagonalUpTasks);
};
bridgeTask = fun (px, py, pz, direction, itemString){
    direction = Direction.fromString(direction);
    if(!direction.isValid()){
        messageHolder.sendMessageUnchecked("Direction name was not valid");
        return;
    }
    bridgeTasks = new CyclicTaskGenerator(new PosWithFun(px,py,pz));
    bridgeTasks.addAction(new Task(new PosWithFun(0,0,0), itemString, null));
    bridgeTasks.blockSize = new PosWithFun(0,0,0).offset(direction);
    taskHolder.add(bridgeTasks);
};

toggleActionBarTask = fun (){
    messageHolder.actionbar = !messageHolder.actionbar;
};
//generate Scope with predicate, function for nearby blockPos
PositionPredicateFunctionTask = fun (predicate, actionFunction, itemGetter) {return fun (){
    item = itemGetter();
    centerPos = new PosWithFun(player.getPos());
    ranged = world.getPositions(centerPos.add(new PosWithFun(playerReach, playerReach, playerReach)).asPos(), centerPos.subtract(new PosWithFun(playerReach, playerReach, playerReach)).asPos());
    foreach (pos : ranged){
        if (predicate(pos)){
            messageHolder.sendDebugMessage("Action found for "+ pos);
            if (actionFunction(pos, item)){
                messageHolder.sendDebugMessage("Action found for "+ pos + " should sleep");
                return true;
            }
        }
    };
    return false;
};
};
fun predicateSpawnProof(pos){
    if (!spawnProofTaskOn){
        return false;
    }
    boolean = !singleUsePosSet.contains(pos) && spawnChecker.getNormalSpawnProof(pos)!= null && new PosWithFun(pos).isNear(player, playerReach);
    if (boolean){
        singleUsePosSet.add(pos);
        return true;
    }
    return false;
}

fun actionPlaceSpawnproofNearby(pos, item){
    //messageHolder.sendDebugMessage(pos);
    task = new Task(pos, item, null);
    task.ignoreDistance = true;
    task.executeOrElse();
    return false;
}

fun predicatePlacePower(pos){
    if (railPoweringTaskOff){
        return false;
    }
    boolean = world.getBlockAt(pos).getId() == 'powered_rail' && !world.getBlockAt(pos).getBlockProperties().get("powered");
    if (boolean){
        //its non-powered powered rail
        return true;
    }
    return false;
}
fun actionPlacePowerNearby(pos, railPowerItem){
    foreach (directions : Direction.horizontal()){
        newPos = new PosWithFun(pos).offset(directions);
        newPosBelow = newPos.down();
        if (world.getBlockAt(newPosBelow.asPos()).isReplaceable() && world.getBlockAt(newPos.asPos()).isReplaceable()){
            //messageHolder.sendDebugMessage(newPosBelow.formatted());
            new Task(newPosBelow, railPowerItem, null).execute();
            new Task(newPos, 'redstone_torch', Direction.DOWN).execute();
            sleep(300);
            return true;
        }
    }
    return false;
}

//suggesters

rayTraceX = fun (args...){
    block = player.getLookingAtBlock();
    if (block.getId().contains('air')){
        return [Math.round(player.getPos().getX())];
    }
    return [player.getLookingAtBlock().getX()];
};
rayTraceY = fun (args...){
    block = player.getLookingAtBlock();
    if (block.getId().contains('air')){
        return [Math.round(player.getPos().getY())];
    }
    return [player.getLookingAtBlock().getY()];
};
rayTraceZ = fun (args...){
    block = player.getLookingAtBlock();
    if (block.getId().contains('air')){
        return [Math.round(player.getPos().getZ())];
    }
    return [player.getLookingAtBlock().getZ()];
};
toggleRailPoweringTask = fun (newBool){
    railPoweringTaskOff = !newBool;
    messageHolder.sendMessageUnchecked('Rail powering task is set to '+ (!railPoweringTaskOff));
};
setRailPowerItem = fun (newItem){
    railPowerItem = newItem;
    messageHolder.sendMessageUnchecked('Rail power support item is set to ' + newItem);
};
setPistonItemTask = fun (newPiston){
    if (newPiston.contains('piston'));
        pistonItem = newPiston;
    messageHolder.sendMessageUnchecked('Piston item is set to ' + newPiston);
};

toggleSpawnProofTask = fun (newBool){
    spawnProofTaskOn = newBool;
    messageHolder.sendMessageUnchecked('Spawnproof task is set to '+ (spawnProofTaskOn));
};
setSpawnProofItemTask = fun (newItem){
    spawnProofItem = newItem;
    messageHolder.sendMessageUnchecked('Spawnproof item is set to ' + newItem);
};
func = PositionPredicateFunctionTask(predicatePlacePower, actionPlacePowerNearby, fun(){return railPowerItem;});
taskFunctionHolder.add(func);
func = PositionPredicateFunctionTask(predicateSpawnProof, actionPlaceSpawnproofNearby, fun(){return spawnProofItem;});
taskFunctionHolder.add(func);
//Register commands.
new LinearCommand([['efill'],['x', 'Integer', rayTraceX],['y', 'Integer', rayTraceY],['z', 'Integer', rayTraceZ],['ex', 'Integer', rayTraceX],['ey', 'Integer', rayTraceY],['ez', 'Integer', rayTraceZ],['itemName', 'Word', DefaultSuggester.BLOCKS]], fillTask).process();
new LinearCommand([['eBreak'],['x', 'Integer', rayTraceX],['y', 'Integer', rayTraceY],['z', 'Integer', rayTraceZ],['ex', 'Integer', rayTraceX],['ey', 'Integer', rayTraceY],['ez', 'Integer', rayTraceZ]], breakTask).process();
new LinearCommand([['efill'],['x', 'Integer', rayTraceX],['y', 'Integer', rayTraceY],['z', 'Integer', rayTraceZ],['ex', 'Integer', rayTraceX],['ey', 'Integer', rayTraceY],['ez', 'Integer', rayTraceZ],['itemName', 'Word', DefaultSuggester.BLOCKS], ['direction', 'Word', DefaultSuggester.DIRECTIONS]], fillDirectionTask).process();
new LinearCommand([['eCommand'],['pause']], pauseTask).process();
new LinearCommand([['eCommand'],['toggleMessage']], toggleMessageTask).process();
new LinearCommand([['eCommand'],['toggleActionBar']], toggleActionBarTask).process();
new LinearCommand([['eRailPowering'],['bool', 'Boolean']], toggleRailPoweringTask).process();
new LinearCommand([['eRailPowering'],['setItem'], ['newItem', 'Word', DefaultSuggester.BLOCKS]], setRailPowerItem).process();
new LinearCommand([['eSpawnproof'],['bool', 'Boolean']], toggleSpawnProofTask).process();
new LinearCommand([['eSpawnproof'],['setItem'], ['newItem', 'Word', DefaultSuggester.BLOCKS]], setSpawnProofItemTask).process(); //setPistonItemTask
new LinearCommand([['eCommand'],['AccurateBlockPlacement'], ['bool', 'Boolean']], toggleProtocolTask).process();
new LinearCommand([['eCommand'],['toggleTrustClient']], trustClientTask).process();
new LinearCommand([['eCommand'], ['setInterval'], ['milliseconds', 'Integer']], intervalChangeTask).process();
new LinearCommand([['eCommand'], ['setBlockPlacmentInterval'], ['milliseconds', 'Integer']], blockIntervalChangeTask).process();
new LinearCommand([['eCommand'], ['expectedServerPing'], ['milliseconds', 'Integer']], serverPingChangeTask).process();
new LinearCommand([['eDiagonalPlace'], ['x', 'Integer', rayTraceX],['y', 'Integer', rayTraceY],['z', 'Integer', rayTraceZ], ['direction', 'Word', DefaultSuggester.HORIZONTAL], ['itemString', 'Word', DefaultSuggester.BLOCKS]], diagonalUpTask).process();
new LinearCommand([['eBridge'], ['x', 'Integer', rayTraceX],['y', 'Integer', rayTraceY],['z', 'Integer', rayTraceZ], ['direction', 'Word',  DefaultSuggester.DIRECTIONS], ['itemString', 'Word', DefaultSuggester.BLOCKS]], bridgeTask).process();
new LinearCommand([['eDemiBolt'], ['x', 'Integer', rayTraceX],['y', 'Integer', rayTraceY],['z', 'Integer', rayTraceZ], ['direction', 'Word', ['north', 'west', 'east', 'south']]], demiBoltTask).process();
new LinearCommand([['eStandardBolt'], ['x', 'Integer', rayTraceX],['y', 'Integer', rayTraceY],['z', 'Integer', rayTraceZ], ['direction', 'Word', ['north', 'west', 'east', 'south']]], standardBoltTask).process();
new LinearCommand([['eDiagonalBolt'], ['x', 'Integer', rayTraceX],['y', 'Integer', rayTraceY],['z', 'Integer', rayTraceZ], ['direction', 'Word', ['north', 'west', 'east', 'south']]], diagonalBoltTask).process();
new LinearCommand([['eCommand'], ['setReachDistance'], ['reachDistance', 'Double']], reachDistanceTask).process();
new LinearCommand([['eBedrockBreaking'],  ['setItem'], ['itemName', 'Word', ['piston', 'sticky_piston']]], setPistonItemTask).process();
new LinearCommand([['eBedrockBreaking'],  ['x', 'Integer', rayTraceX],['y', 'Integer', rayTraceY],['z', 'Integer', rayTraceZ], ['headless', 'Boolean']], breakingTask).process();
new LinearCommand([['eBedrockBreaking'],  ['setPos1'] ,['x', 'Integer', rayTraceX],['y', 'Integer', rayTraceY],['z', 'Integer', rayTraceZ]], setAreaPos1Task).process();
new LinearCommand([['eBedrockBreaking'],  ['setPos1'] ,['rayTrace']], setAreaPos1RayTraceTask).process();
new LinearCommand([['eBedrockBreaking'],  ['setPos2'] ,['x', 'Integer', rayTraceX],['y', 'Integer', rayTraceY],['z', 'Integer', rayTraceZ]], setAreaPos2Task).process();
new LinearCommand([['eBedrockBreaking'],  ['setPos2'] ,['rayTrace']], setAreaPos2RayTraceTask).process();
new LinearCommand([['eBedrockBreaking'],  ['x', 'Integer', rayTraceX],['y', 'Integer', rayTraceY],['z', 'Integer', rayTraceZ], ['direction', 'Word', ['north', 'west', 'east', 'south', 'up', 'down']], ['headless', 'Boolean']], headlessTask).process();
new LinearCommand([['eBedrockBreaking'],  ['rayTrace']], breakingLookingAtTask).process();
new LinearCommand([['eBedrockBreaking'],  ['rayTrace'], ['direction', 'Word', ['north', 'west', 'east', 'south', 'up', 'down']], ['headless', 'Boolean']], breakingLookingAtHeadlessTask).process();
new LinearCommand([['eBedrockBreaking'],['Area'], ['x', 'Integer', rayTraceX],['y', 'Integer', rayTraceY],['z', 'Integer', rayTraceZ],['ex', 'Integer', rayTraceX],['ey', 'Integer', rayTraceY],['ez', 'Integer', rayTraceZ]], breakBedrockAreaTask).process();
//setAreaPos1Task
// Script
//t = new Task(new PosWithFun(249,111,206), 'repeater', 'west');
//t.finish();

//t = new CyclicTaskGenerator(new PosWithFun(player.getLookingAtBlock()).up());
//dir = Direction.EAST.rotateYClockwise();
//messageHolder.sendMessage(dir.vector);
//t.getDiagonal(Direction.EAST);
//while (true){
//    t.execute();
//}

//placeWallTorch(new PosWithFun(245,113,243), 'redstone_torch', Direction.EAST);

//How to make waiting task:

//task = pistonExtendRemovalTask(blockPos, facing);
//task = pistonExtendRemovalTask(new PosWithFun(242,112,220), Direction.UP));

//messageHolder.sendMessage(task.isAvailable());
//taskIterator = new TaskIterator();
//task = new WaitingTask(new PosWithFun(242,112,220), 'shroomlight', null, fun (){return world.isAir(new Pos(242,112,217));});
//taskIterator.addAction(task);
//chainedPistonTaskFull(blockPos, facing1, facing2, torchPos,torchPos2, torchFacing,torchFacing2, headless) //its better to have multiple torch pos for headless
//taskIterator = chainedPistonTaskFull(new PosWithFun(242,112,220),UP, SOUTH, new PosWithFun(241,112,220), new PosWithFun(241,112,220), UP, UP, false);
//taskHolder.add(taskIterator);
i = 0;
//torch, pis
//recordPiston = PistonUtils.calculateBreakingPiston(world, new PosWithFun(player.getLookingAtBlock().getPos()));
//if (recordPiston == null){
//    throwRuntimeError('task was null');
//}
//messageHolder.sendMessage(recordPiston.formatted());
//taskIterator = chainedPistonTaskRecord(recordPiston, true);
//taskHolder.add(taskIterator);
while (true){
    if (pause){
        sleep(50);
        continue;
    }
    if (player.getGamemode() == 'spectator'){
        sleep(50);
        continue;
    }
    leftovers.process();
    polled = delayedHolder.poll();
    if (polled != null){
        taskHolder.add(polled);
    }
    foreach (tasks : taskHolder){
        result = tasks.execute();
        //messageHolder.sendMessageUnique(tasks.formatted());
        if (sleepInterval > 0){
            sleep(sleepInterval);
        }
    }
    foreach (functions : taskFunctionHolder){
        retVal = functions();
    }
}


//PistonUtils.calculateValidTorchPos(world, new PosWithFun(232,111,219), NORTH);