import * from Minecraft;
import LinearCommand from minecraft.CommandUtils;
import RGB from minecraft.ColorCodes;
client = MinecraftClient.getClient();
player = client.getPlayer();
world = client.getWorld();
reach = 32;
xreach = 32;
yreach = 32;
zreach = 32;
safetyLimit = 20000000;

globalBoxes = {};
fun getIterator(start, end, num){
    ii = 0;
    maxlen = 1000000;
    ret = [start];
    c = start;
    while (c < end && ii < maxlen){
        c = c+num;
        ret.append(c);
        ii = ii+1;
    }
    return ret;
}
fun iterateFun(reach, function, arguments){
    retVal = [];
    sx = player.getX().round();
    sy = player.getY().round();
    sz = player.getZ().round();
    SxL = getIterator(sx-reach, sx+reach, 1);
    SyL = getIterator(sy-reach, sy+reach, 1);
    SzL = getIterator(sz-reach, sz+reach, 1);
    foreach (Sx : SxL) {
        foreach (Sy : SyL ) {
            foreach (Sz : SzL) {
                pos = new Pos(Sx,Sy,Sz);
                box = function(pos, arguments);
                if (box != null) {
                    retVal.append(box);
                }
            }
        }
    }
    return retVal;
}
fun asString(position){
    return ''+ position.getX().round() + ':'+ position.getY().round()+ ':' + position.getZ().round();
}
fun asBlockPos(string){
    xyz = string.split(':');
    return new Pos(xyz.get(0).toNumber(),xyz.get(1).toNumber(),xyz.get(2).toNumber());
}
fun renderBoxIf(position, containsString){
    if (world.getBlockAt(position).getId().contains(containsString)){
        box = new BoxShape(position);
        box.setOutlineColor(255,0,0);
        box.setOpacity(120);
        box.setRenderThroughBlocks(true);
        return box;
    }
}
fun renderBoxWhatever(position){
    box = new BoxShape(position);
    box.setColour(255,0,0);
    box.setOutlineColor(0,0,0);
    box.setOpacity(20);
    box.setOutlinePixelWidth(15);
    box.setRenderThroughBlocks(true);
    return box;
}
fun renderBoxWhateverColor(position, colorA, colorB, colorC){
    box = new BoxShape(position);
    box.setColour(colorA, colorB, colorC);
    box.setOutlineColor(0,0,0);
    box.setOpacity(20);
    box.setOutlinePixelWidth(15);
    box.setRenderThroughBlocks(true);
    return box;
}
fun renderBoxWhateverColorFromMap(position, color){
    box = new BoxShape(position);
    box.setColour(color.hexcode);
    box.setOutlineColor(0,0,0);
    box.setOpacity(20);
    box.setOutlinePixelWidth(15);
    box.setRenderThroughBlocks(true);
    return box;
}
fun renderBoxWhateverColorFromMapBlock(blocks, color){
    position = blocks.getPos();
    box = new BoxShape(position);
    box.setColour(color.hexcode);
    box.setOutlineColor(0,0,0);
    box.setOpacity(20);
    box.setOutlinePixelWidth(15);
    box.setRenderThroughBlocks(true);
    return box;
}
fun iterateFunJava(reach, arguments){
    retVal = [];
    sx = player.getX().round();
    sy = player.getY().round();
    sz = player.getZ().round();
    area = world.getAreaMatch(new Pos(sx-reach, sy-reach, sz-reach), new Pos(sx+reach, sy+reach, sz+reach), arguments);
    foreach( pos: area){
        retVal.append(renderBoxWhatever(pos));
    }
    return retVal;
}
fun iterateFunJavaColorMapping(reach, arguments){
    retVal = [];
    sx = player.getX().round();
    sy = player.getY().round();
    sz = player.getZ().round();
    area = world.getAreaMatch(new Pos(sx-reach, sy-reach, sz-reach), new Pos(sx+reach, sy+reach, sz+reach), arguments);
    foreach( Obj: area){
        retVal.append(renderBoxWhateverColorFromMap(Obj.get(0), Obj.get(1)));
    }
    return retVal;
}
fun getOptional(map, what){
    if (map == null || !map.instanceOf("Map") || map.get(what) == null){
        return null;
    }
    return map.get(what);
}
fun predicateEntity(position){
    posBlock = world.getBlockAt(position);
    map = posBlock.getBlockEntityData();
    optional = getOptional(map, 'storedStack');
    if (optional == null){
        return false;
    }
    return optional.get('id').contains(string);
}
fun predicateEntity2(position){
    posBlock = world.getBlockAt(position);
    map = posBlock.getBlockEntityData();
    optional = getOptional(map, 'SpawnData');
    if (optional == null){
        return false;
    }
    return optional.get('entity').get('id').contains('zombie');
}
fun predicateEntity3(position){
    posBlock = world.getBlockAt(position);
    cond1 = posBlock.getId().contains('something');
    if(!cond1){
        return false;
    }
    map = posBlock.getBlockEntityData();
    optional = getOptional(map, 'Items');
    if (optional == null){
        return false;
    }
    return optional.get('Items').get(0).get('id').contains('item_');
}
fun iterateFunJavaPredicate(reach, function){
    retVal = [];
    sx = player.getX().round();
    sy = player.getY().round();
    sz = player.getZ().round();
    //area = world.getAreaPredicate(new Pos(sx-reach, sy-reach, sz-reach), new Pos(sx+reach, sy+reach, sz+reach), function);
    area = world.getArea(new Pos(sx-reach, sy-reach, sz-reach), new Pos(sx+reach, sy+reach, sz+reach));
    foreach( pos: area){
        if(function(pos)){
            retVal.append(renderBoxWhatever(pos));
        }
    }
    return retVal;
}
fun iterateFunJavaPredicateColored(coloredfunction, mapping){
    retVal = [];
    sx = player.getX().round();
    sy = player.getY().round();
    sz = player.getZ().round();
    //area = world.getAreaPredicate(new Pos(sx-reach, sy-reach, sz-reach), new Pos(sx+reach, sy+reach, sz+reach), function);
    tt = getMilliTime();
    area = world.getArea(new Pos(sx-xreach, sy-yreach, sz-zreach), new Pos(sx+xreach, sy+yreach, sz+zreach));
    //player.messageActionBar("preparing " + ((2* reach+1)^3) + " blocks list took" + (getMilliTime() - tt)+ "ms");
    foreach( pos: area){
        color = coloredfunction(pos, mapping);
        if(color != false){
            retVal.append(renderBoxWhateverColorFromMap(pos, color));
        }
    }
    return retVal;
}
fun iterateFunJavaPredicateColoredBlock(coloredfunctionBlock, mapping){
    retVal = [];
    sx = player.getX().round();
    sy = player.getY().round();
    sz = player.getZ().round();
    //area = world.getAreaPredicate(new Pos(sx-reach, sy-reach, sz-reach), new Pos(sx+reach, sy+reach, sz+reach), function);
    tt = getMilliTime();
    area = world.getAreaOfBlocks(new Pos(sx-xreach, sy-yreach, sz-zreach), new Pos(sx+xreach, sy+yreach, sz+zreach));
    //player.messageActionBar("preparing " + ((2* reach+1)^3) + " blocks list took" + (getMilliTime() - tt)+ "ms");
    foreach( blocks: area){
        color = coloredfunctionBlock(blocks, mapping);
        if(color != false){
            retVal.append(renderBoxWhateverColorFromMapBlock(blocks, color));
        }
    }
    return retVal;
}
fun getDistanceTo(pos){
    return ((player.getX() - pos.getX()) ^2 + (player.getY() - pos.getY()) ^2+(player.getZ() - pos.getZ()) ^2)^0.5;
}
fun highlightJava(string) {
    range = 24;
    globalBoxes = iterateFunJava(range, string);
    while (true){
        foreach (boxes : globalBoxes){
            boxes.render();
        }
        globalBoxesNext = iterateFunJava(range,  string);
        foreach (boxes : globalBoxesNext){
            boxes.render();
        }
        foreach (boxes : globalBoxes){
            boxes.stopRendering();
        }
        globalBoxes = globalBoxesNext;
    }
}
fun highlightJavaPredicate(predicate) {
    range = 24;
    globalBoxes = iterateFunJavaPredicate(range, predicate);
    while (true){
        foreach (boxes : globalBoxes){
            boxes.render();
        }
        globalBoxesNext = iterateFunJavaPredicate(range,  predicate);
        foreach (boxes : globalBoxesNext){
            boxes.render();
        }
        foreach (boxes : globalBoxes){
            boxes.stopRendering();
        }
        globalBoxes = globalBoxesNext;
    }
}
fun highlightJavaPredicateColor(predicate, mapping) {
    globalBoxes = iterateFunJavaPredicateColored(predicate, mapping);
    st = getMilliTime();
    while (true){
        foreach (boxes : globalBoxes){
            boxes.render();
        }
        globalBoxesNext = iterateFunJavaPredicateColored(predicate, mapping);
        player.messageActionBar("Search/Rendering for " + ((2* xreach+1) *(2* yreach+1) *(2* zreach+1) ) + " blocks took " + (getMilliTime() - st)+ "ms");
        st = getMilliTime();
        foreach (boxes : globalBoxesNext){
            boxes.render();
        }
        foreach (boxes : globalBoxes){
            boxes.stopRendering();
        }
        globalBoxes = globalBoxesNext;
    }
}
fun highlightJavaPredicateColorBlock(blockPredicate, mapping) {
    globalBoxes = iterateFunJavaPredicateColoredBlock(blockPredicate, mapping);
    //benchmark
    st = getMilliTime();
    while (true){
        foreach (boxes : globalBoxes){
            boxes.render();
        }
        globalBoxesNext = iterateFunJavaPredicateColoredBlock(blockPredicate, mapping);
        player.messageActionBar("Search/Rendering for " + ((2* xreach+1) *(2* yreach+1) *(2* zreach+1) ) + " blocks took " + (getMilliTime() - st)+ "ms");
        st = getMilliTime();
        foreach (boxes : globalBoxesNext){
            boxes.render();
        }
        foreach (boxes : globalBoxes){
            boxes.stopRendering();
        }
        globalBoxes = globalBoxesNext;
    }
}
fun highlight(string) {
    range = 32;
    globalBoxes = iterateFun(range,renderBoxIf, string);
    while (true){
        foreach (boxes : globalBoxes){
            boxes.render();
        }
        globalBoxesNext = iterateFun(range, renderBoxIf,  string);
        foreach (boxes : globalBoxesNext){
            boxes.render();
        }
        foreach (boxes : globalBoxes){
            boxes.stopRendering();
        }
        globalBoxes = globalBoxesNext;
    }
}
fun predicateMap(position, mappings) {
    id = world.getBlockAt(position).getId();
    // Flexible containsString
    foreach (values : mappings.getKeys()){
        if (id.contains(values)){
            return mappings.get(values);
        }
    }
    // Fixed block search
    // if (mapping.contains(id)){
    //    return mapping.get(id);
    // }
    return false;
}
fun predicateMapBlock(block, mappings) {
    id = block.getId();
    // Flexible containsString
    foreach (values : mappings.getKeys()){
        if (id.contains(values)){
            return mappings.get(values);
        }
    }
    // Fixed block search
    // if (mapping.contains(id)){
    //    return mapping.get(id);
    // }
    return false;
}
fun predicate(position){
    id = world.getBlockAt(position).getId();
    //return id.contains('spawner');
    return id.contains('stone');
}

class VarRGB{
    var r;
    var g;
    var b;
    VarRGB(r,g,b){
        this.r = r;
        this.g = g;
        this.b = b;
        this.hexcode = b+ 256 * g + 65536 * r;
    }
}
//tasks
xdistanceTask = fun (newVal){
    if((2* newVal+1) *(2* yreach+1) *(2* zreach+1) > safetyLimit){
        player.message("Block Area count of " +((2* xreach+1) *(2* yreach+1) *(2* zreach+1)) + " will exceed safety count " + safetyLimit);
        return;
    }
    if(newVal > 0){
        xreach = newVal;
    }
};
ydistanceTask = fun (newVal){
    if((2* xreach+1) *(2* newVal+1) *(2* zreach+1) > safetyLimit){
        player.message("Block Area count of " +((2* xreach+1) *(2* yreach+1) *(2* zreach+1)) + " will exceed safety count " + safetyLimit);
        return;
    }
    if(newVal > 0){
        yreach = newVal;
    }
};
zdistanceTask = fun (newVal){
    if((2* xreach+1) *(2* yreach+1) *(2* newVal+1) > safetyLimit){
        player.message("Block Area count of " +((2* xreach+1) *(2* yreach+1) *(2* zreach+1)) + " will exceed safety count " + safetyLimit);
        return;
    }
    if(newVal > 0){
        zreach = newVal;
    }
};
safetyCountTask = fun (newVal){
    safetyLimit = newVal;
    player.message("Safety count is now set to " + safetyLimit);
};
fixedColorMapping = {};
addSearchTask = fun (newVal,colour){
    mapping.put(newVal, colour);
    player.message("Toggled " +newVal + " search");
};
addSearchRGBTask = fun (newVal,r,g,b){
    mapping.put(newVal, new VarRGB(r,g,b));
    player.message("Toggled " +newVal + " search");
};
removeSearchTask = fun (val){
    if (mapping.contains(val)){
        mapping.remove(val);
        player.message("Removed " +newVal + " search");
    }

};
mapping = {
    //'diamond' : [0, 216, 255],
    //'redstone' : [255,0,0],
    //'gold' : [255,224,0],
    // 'ender_chest' : [0,0,255],
    // 'ancient' : [255,124,0],
    // 'bee_nest' : [255,224,0]
};
new LinearCommand([['highlight'], ['remove'], ['string', 'Word']], removeSearchTask).process();
new LinearCommand([['highlight'], ['add'], ['string', 'Word'], ['color', 'Enum', RGB.type]], addSearchTask).process();
new LinearCommand([['highlight'], ['add'], ['string', 'Word'], ['R', 'Integer', 0, 255], ['G', 'Integer', 0, 255], ['B', 'Integer', 0, 255]], addSearchRGBTask).process();
new LinearCommand([['highlight'], ['setXDistance'], ['distance', 'Integer',1,255]], xdistanceTask).process();
new LinearCommand([['highlight'], ['setYDistance'], ['distance', 'Integer',1,255]], ydistanceTask).process();
new LinearCommand([['highlight'], ['setZDistance'], ['distance', 'Integer',1,255]], zdistanceTask).process();
//highlightJavaPredicate(predicate);
thread = Thread.runThreaded(fun (){highlightJavaPredicateColor(predicateMap, mapping);});
//thread = Thread.runThreaded(fun (){highlightJavaPredicateColorBlock(predicateMapBlock, mapping);});
//highlightJavaPredicateColor(predicateMap, mapping);
while(true){
    sleep(150);
}